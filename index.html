<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>A Tour of C++</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="16c5dd5d-2d97-805f-9d7c-dc870bda1af2" class="page sans"><header><h1 class="page-title">A Tour of C++</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-created_time"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedAt"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM4.54102 8.91211H7.99316C8.30078 8.91211 8.54004 8.67285 8.54004 8.37207V3.8877C8.54004 3.58691 8.30078 3.34766 7.99316 3.34766C7.69238 3.34766 7.45312 3.58691 7.45312 3.8877V7.83203H4.54102C4.2334 7.83203 4.00098 8.06445 4.00098 8.37207C4.00098 8.67285 4.2334 8.91211 4.54102 8.91211Z"></path></svg></span>Created</th><td><time>@December 30, 2024 2:56 PM</time></td></tr><tr class="property-row property-row-select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesSelect"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM7.62402 10.6348C7.79492 10.915 8.20508 10.9287 8.37598 10.6348L10.666 6.73145C10.8574 6.41016 10.7002 6.04102 10.3652 6.04102H5.62793C5.29297 6.04102 5.14941 6.43066 5.32031 6.73145L7.62402 10.6348Z"></path></svg></span>Class</th><td><span class="selected-value select-value-color-pink">C++</span></td></tr></tbody></table></header><div class="page-body"><p id="1765dd5d-2d97-80c6-b1dd-d475366e7b8b" class="">
</p><h1 id="17f5dd5d-2d97-802e-8707-f1718d9b5687" class="">Chapter 1: The Basics</h1><p id="17f5dd5d-2d97-8094-a9cd-e15bd184b6e7" class="">When we want a type of specific size, use STL alias, such as <mark class="highlight-blue"><code><strong>int32_t</strong></code></mark></p><p id="17f5dd5d-2d97-80a1-bbbe-ee8cd396784a" class="">To make long literals more readable for humans, use <mark class="highlight-blue"><code><strong>‘ </strong></code></mark>as digit separator. pi is <mark class="highlight-blue"><code><strong>3.14159’26535’89793</strong></code></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80b9-99ea-f5970d3efd67" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int i1 = 7.8; // (narrowing conversion - i1 = 7), a price to pay for C compatibility
int i2{7.8}; // error: floating-point to integer conversion</code></pre><h3 id="17f5dd5d-2d97-8091-a9e5-dd1b4f4dcf39" class=""><mark class="highlight-default">Scope and Lifetime</mark></h3><p id="17f5dd5d-2d97-80c6-8b4d-f3cb2bd50d08" class="">local scope: block scope, inside function/lambda.</p><p id="17f5dd5d-2d97-8015-8467-e9b02e2bfd58" class="">class scope: member of class, outside function/lambda/enum class</p><p id="17f5dd5d-2d97-8024-b720-d116e71d43fb" class="">namespace scope: namespace outside of any function, lambda, class or enum.</p><p id="17f5dd5d-2d97-803f-9056-e859d3bde0c9" class="">global name: global namespace</p><p id="17f5dd5d-2d97-8018-bb02-cce0b7bfc984" class="">
</p><h3 id="17f5dd5d-2d97-8091-8851-fe2206550d37" class="">Constants</h3><p id="17f5dd5d-2d97-80c8-9b60-e101d58e1047" class=""><mark class="highlight-blue"><code><strong>const</strong></code></mark>: used to specify interfaces so that data can be passed without being modified. Compiler enforces the promise made by const. Value of <mark class="highlight-blue"><code><strong>const</strong></code></mark> may be calculated at run-time.</p><p id="17f5dd5d-2d97-80d6-b7d8-d7eb6a99d940" class=""><mark class="highlight-blue"><code><strong>constexpr</strong></code></mark>: to be evaluated at compile-time. Used to specify constants, placement of data in read-only memory, and for performance. Value of <mark class="highlight-blue"><code><strong>constexpr</strong></code></mark> must be calculated by compiler.</p><p id="17f5dd5d-2d97-8099-8770-d4842975ba71" class=""><mark class="highlight-blue"><code><strong>consteval:</strong></code></mark> when we want a function to be used <em>only</em> for evaluation at compile time, we declare it <mark class="highlight-blue"><code><strong>consteval</strong></code></mark> rather than <mark class="highlight-blue"><code><strong>constexpr</strong></code></mark>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80b4-ad8f-d047e22ba6cb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">constexpr double square(double x) { return x*x; }
constexpr double max1 = 1.4*square(17); // OK: 1.4*square(17) is constant expression
constexpr double max2 = 1.4*square(var); // error: var is not constant, square(var) is not constexpr
const double max3 = 1.4*square(var); // OK: 1.4*square(var) being evaluated at run time

consteval double square2(double x) { return x*x; }
constexpr double max4 = 1.4*square(17); // OK: 1.4*square(17) is constant expression
const double max5 = 1.4*square(var); // Error: var is not constant</code></pre><p id="1805dd5d-2d97-80e9-90c3-eb1b450882a9" class="">
</p><h3 id="1805dd5d-2d97-80a9-8d4e-ed91018f769d" class="">Initialization</h3><p id="1805dd5d-2d97-80e2-a9f6-d771eb6306d0" class="">For almost all types, the effect of reading from or writing to an uninitialized variable is undefined.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-800a-a282-df4d839c44ac" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int x = 7;
int&amp; r{x}; // bind r to x (reference only can bind once)
r = 10; // assign r to 10, x also equals 10

int&amp; r2; // error: uninitialized refernce
r2 = 99; // assigning 99 to some unspecified memory location could lead to bad results/crash
</code></pre><p id="1805dd5d-2d97-80fb-a394-d0faa1db156d" class="">
</p><h1 id="1805dd5d-2d97-8045-ab75-f3bc78ff43e9" class="">Chapter 2: User-Defined Types</h1><p id="1805dd5d-2d97-8085-b52b-edb260419de5" class="">There is no difference between class and struct. Struct is simply a class with members public by default.</p><h3 id="1805dd5d-2d97-8090-a531-ee78c3b2ac3b" class="">Enumerations</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-80e1-a352-e38c5f22205d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color x1 = red; // error: which red?
auto x2 = Color::red; // OK: Color::red is Color
Color x3 = 2; // initialization error: Color is not int

Color x4{2}; // OK- since enum underlying type by default is int
int i = int(Color::red); // OK: explicitly convert enum value to its underlying type</code></pre><p id="1805dd5d-2d97-80d4-ab89-cf5b3c0559ae" class="">If you don’t want to explicitly qualify enumerator names and values to be ints (without explicit conversion i<mark class="highlight-blue"><code><strong>nt i = int(Color::red)</strong></code></mark>), consider removing <mark class="highlight-blue"><code><strong>class</strong></code></mark> from <mark class="highlight-blue"><code><strong>enum class</strong></code></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-803a-ae5d-c00108a7c6ae" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">enum Color { red, green, blue };
int col = red; // OK: implicit conversion to int. col = 0</code></pre><p id="1805dd5d-2d97-804f-b0a3-efe5936f9dda" class="">
</p><h3 id="1805dd5d-2d97-809c-b697-fa4ef2facc0b" class="">Union</h3><p id="1805dd5d-2d97-8041-bca6-fd322092567c" class="">If members <mark class="highlight-blue"><code><strong>p</strong></code></mark> and <mark class="highlight-blue"><code><strong>i</strong></code></mark> of <mark class="highlight-blue"><code><strong>Value</strong></code></mark> are never used at the same time, consider the use of union. However, the language doesn’t keep track of which kind of value is held by union, so programmer must do that.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-80b9-a6fc-cac8d997beaf" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">union Value {
	Node* p;
	int i;
}; // space optimization: union occupies only as much space as its largest member

struct Entry {
	string name;
	Type t;
	Value v; // use v.p if t==Type::ptr, use v.i if t==Type::num (use enum Type for mannual bookkeeping)
};</code></pre><p id="1805dd5d-2d97-802c-861e-c1723d9128da" class="">
</p><h1 id="1805dd5d-2d97-805a-9262-e3b09a925d89" class="">Chapter 3: Modularity</h1><p id="1805dd5d-2d97-807d-960f-e184f7501921" class="">Separate compilation where user code sees only declarations of the types and functions used. Can be done via:</p><ul id="1805dd5d-2d97-8074-821a-e8e88bb0450c" class="bulleted-list"><li style="list-style-type:disc">Header files: <mark class="highlight-blue"><code><strong>#include</strong></code></mark> a header file where its declarations are needed</li></ul><ul id="1805dd5d-2d97-807a-bba8-cf95ebb7cda0" class="bulleted-list"><li style="list-style-type:disc">Modules (C++ 20): Define <mark class="highlight-blue"><code><strong>module</strong></code></mark> files, compile them separately, and <mark class="highlight-blue"><code><strong>import</strong></code></mark> them where needed.</li></ul><p id="1805dd5d-2d97-80ef-aa7a-e1d9c2210c10" class="">
</p><h3 id="1805dd5d-2d97-80c0-a0b6-f9d57482eec5" class="">Header files</h3><p id="1805dd5d-2d97-8034-aa19-c6183a565cc3" class="">Consider declaration that specify the interface in <mark class="highlight-blue"><code><strong>Vector.h</strong></code></mark>. Then, the code in <mark class="highlight-blue"><code><strong>user.cpp</strong></code></mark> (get and use Vector’s interface) and <mark class="highlight-blue"><code><strong>Vector.cpp</strong></code></mark> (implementation, definition of Vector) shares the Vector interface, but are independent and separately compiled.</p><p id="1805dd5d-2d97-80a4-8b3e-c8b6d0028c4d" class="">
</p><p id="1805dd5d-2d97-80c7-8086-c00e178fe935" class="">A <mark class="highlight-blue"><code><strong>.cpp</strong></code></mark> file that is compiled by itself (including the <mark class="highlight-blue"><code><strong>h</strong></code></mark> files it <mark class="highlight-blue"><code><strong>#include</strong></code></mark>) is called a <em>translation unit</em>. Disadvantages of using header files:</p><ul id="1805dd5d-2d97-8082-8393-e2cce3b4936d" class="bulleted-list"><li style="list-style-type:disc">Compilation time: If <mark class="highlight-blue"><code><strong>#include header.h</strong></code></mark> in 100 translation units, the text of <mark class="highlight-blue"><code><strong>header.h</strong></code></mark> is processed by compiler 100 times.</li></ul><ul id="1805dd5d-2d97-80a8-968f-f7d55944e49f" class="bulleted-list"><li style="list-style-type:disc">Order dependencies: If <mark class="highlight-blue"><code><strong>#include header1.h</strong></code></mark> before <mark class="highlight-blue"><code><strong>header2.h</strong></code></mark> in declarations and macros, <mark class="highlight-blue"><code><strong>header1.h</strong></code></mark> might affect the code in <mark class="highlight-blue"><code><strong>header2.h</strong></code></mark>.</li></ul><ul id="1805dd5d-2d97-8041-89d7-d6e691694bff" class="bulleted-list"><li style="list-style-type:disc">Transitivity: All code needed to express a declaration in a header file must be present. Because header files may <mark class="highlight-blue"><code><strong>#include</strong></code></mark> other header files.</li></ul><p id="1805dd5d-2d97-80d0-beff-fea5a6692108" class="">
</p><p id="1805dd5d-2d97-8073-a530-fab7b1980731" class="">Alternative: In the <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> and <a href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a> programming languages, <code><strong>#pragma once</strong></code> is a non-standard but widely supported <a href="https://en.wikipedia.org/wiki/C_preprocessor">preprocessor directive</a> designed to cause the current header file to be included only once in a single compilation.</p><p id="1805dd5d-2d97-8033-a5ef-c1fe4fbbccd5" class="">
</p><h3 id="1805dd5d-2d97-805b-ad87-cfca550f6667" class="">Modules</h3><p id="1805dd5d-2d97-80d1-8fc6-f7a2e15934dc" class="">A module is compiled once only, rather than in each translation unit. 2 modules can be imported in either order without changing their meaning. import is not transitive (users of your module do not implicitly gain access should your module <mark class="highlight-blue"><code><strong>#include </strong></code></mark>or <mark class="highlight-blue"><code><strong>import</strong></code></mark> something).</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-8069-9276-ce14a4975b34" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// in Vector.cpp
export module Vector; // defining a module called &quot;Vector&quot;
export class Vector {
 // ...
};
export bool operator==(const Vector&amp; v1, const Vector&amp; v2) 
{
	// ...
}

// in user.cpp
import Vector;
#include &lt;cmath&gt; // you can mix #include with import
double sqrt_sum(Vector&amp; v) { ... }</code></pre><p id="1805dd5d-2d97-80a4-af7a-c2b30fbd19e4" class="">
</p><h3 id="1805dd5d-2d97-8020-bdca-d6976423bd39" class="">Return Type</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-80bb-a3c5-d10000ec6334" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">auto mul(int i, double d) { return i*d; } // here &quot;auto&quot; means &quot;deduce the return type from the return value&quot;
auto next_elem() -&gt; Elem** // different notation </code></pre><p id="1805dd5d-2d97-8040-aa6b-e6f41ad99773" class="">
</p><h3 id="1805dd5d-2d97-8091-b8fc-e163cfa0a2b2" class="">Structured Binding</h3><p id="1805dd5d-2d97-8048-8151-dd6e7b8e92cd" class="">Structured binding does not imply a copy of the struct, returns types are constructed directly. Note that it is used for a class with no private data.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-8004-be4c-e5e85e018cb6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Entry {
	string name;
	int value;
};

Entry read_entry(istreams&amp; is) { ... }
auto [name, val] = read_entry(is);

// common usage
map&lt;string, int&gt; mp;
for (const auto [key, value] : mp) { ... }</code></pre><p id="1805dd5d-2d97-8022-939f-e61d440aeb7e" class="">
</p><h1 id="1805dd5d-2d97-8060-ae10-fa374b61ffcf" class="">Chapter 4: Error Handling</h1><h3 id="1805dd5d-2d97-8078-b608-c5078f113a23" class="">Throw Exceptions</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-8058-837c-f7656768114a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">double&amp; Vector::operator[](int i) {
	if (!(0&lt;i &amp;&amp; i&lt;size()) {
		throw out_of_range{&quot;Vector::operator[]&quot;};
	}
	return elem[i];
}

void f(Vector&amp; v) {
	try {
		// ...
	} catch (const out_of_range&amp; err) {
		cerr &lt;&lt; err.what() &lt;&lt; &#x27;\n&#x27;;
	} catch (const std::length_error&amp; err) {
		// .. handle negative size
	} catch (const std::bad_alloc&amp; err) {
		// ... handle memory exhaustion
	}
}</code></pre><p id="1805dd5d-2d97-80ae-9d77-d28316defad2" class="">Throw transfers control to handler for exceptions of the type <mark class="highlight-blue"><code><strong>out_of_range</strong></code></mark> is some function that called <mark class="highlight-blue"><code><strong>Vector::operator[]()</strong></code></mark>. It will unwind the function call stack to get back to the context of that caller. </p><p id="1805dd5d-2d97-80cf-9be5-c036494f2728" class="">
</p><h3 id="1805dd5d-2d97-80be-89d1-ee43027ebaa5" class="">Error Handling Alternatives</h3><ul id="1805dd5d-2d97-8078-85df-cd040748cd47" class="bulleted-list"><li style="list-style-type:disc">Return value (error code): A failure is normal and expected, for example opening a file that does not exist, or error happens is one of a set of parallel tasks - we need to know which task failed.</li></ul><ul id="1805dd5d-2d97-806d-9959-d14c239b90b9" class="bulleted-list"><li style="list-style-type:disc">Throw Exception: when error cannot be handle by immediate caller, prelocate back up the call chain.</li></ul><ul id="1805dd5d-2d97-8021-87cf-e8d73f233880" class="bulleted-list"><li style="list-style-type:disc">Terminate: We cannot recover from the error, such as memory exhaustion. Restarting a thread, process or computer.</li></ul><p id="1805dd5d-2d97-807a-bf09-eb9949f64b93" class="">
</p><h3 id="1805dd5d-2d97-809c-b0a5-cc948a4ee7ca" class="">assert()</h3><p id="1805dd5d-2d97-8055-a009-d4bbcac1a14e" class=""><mark class="highlight-blue"><code><strong>assert()</strong></code></mark> a condition must hold at <strong>runtime</strong>, else program terminates. If not in <strong>debug</strong> mode, <mark class="highlight-blue"><code><strong>assert()</strong></code></mark> is not checked.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-80fc-a06a-cc013a8177dd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">assert(p != nullptr) // condition must hold at runtime</code></pre><p id="1805dd5d-2d97-80c3-911e-c7ed3d5f9eec" class="">
</p><h3 id="1805dd5d-2d97-804e-b2e5-e9261f3c3120" class="">static_assert()</h3><p id="1805dd5d-2d97-809c-9c12-f0e3bfa2e55c" class="">Perform simple checks on most properties that are known at <strong>compile time</strong>. Once use case of <mark class="highlight-blue"><code><strong>static_assert</strong></code></mark> is to make assertions about the types used as parameters in generic programming.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-80cc-9add-c1e0505894d9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">constexpr double C = 29972.458;
constexpr double local_max = 160;
double speed = 5;
static_assert(speed&lt;C, &quot;can&#x27;t go that fast&quot;); // error: speed must be constant
static_assert(local_max&lt;C, &quot;can&#x27;t go that fast&quot;); // OK</code></pre><p id="1805dd5d-2d97-806a-8e29-d86ee0a2c3d4" class="">
</p><h3 id="1805dd5d-2d97-809a-892d-c97b90c1e8a4" class="">noexcept</h3><p id="1805dd5d-2d97-805d-8b89-f345015c6ce5" class="">A function that should never throw exception can be declared <mark class="highlight-blue"><code><strong>noexcept</strong></code></mark>. However, if exception is still thrown, <mark class="highlight-blue"><code><strong>std::terminate() </strong></code></mark>is called immediately to terminate the program (deemed fatal error).</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1805dd5d-2d97-807c-9980-d4b859913c43" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void user(int sz) noexcept {
	Vector v(sz);
	iota(&amp;v[0],^v[sz],1); // fill v with 1,2,3,4...
	// ...
};</code></pre><h1 id="1765dd5d-2d97-80d3-82d3-d1148d9a520b" class="">Chapter 5: Classes</h1><p id="1805dd5d-2d97-80fc-94e6-fcd1ec82f3d2" class="">By convention, we place <mark class="highlight-blue"><code><strong>public</strong></code></mark> declarations of a class first, and the <mark class="highlight-blue"><code><strong>private</strong></code></mark> declarations later.</p><h3 id="17f5dd5d-2d97-80e7-968e-d9f9f534e962" class="">Abstract Types</h3><p id="17f5dd5d-2d97-80af-b043-f7969a4b2fb8" class="">Concrete classes are placed on stack, and in other objects, initialize copy and move. In contrast, an abstract type (as long as one pure virtual function exist) is a type that completely insulate user from implementation details. Since we don’t know anything about representation of abstract type, not even its size, <mark class="highlight-yellow_background"><strong>we must allocate on the free store</strong></mark> and access them through references or pointers.</p><p id="17f5dd5d-2d97-80d6-b587-f38c923737bd" class="">
</p><p id="17f5dd5d-2d97-80b4-929e-fae048f7394f" class="">The word <mark class="highlight-blue"><code><strong>virtual</strong></code></mark> means “may be redefined later in a class derived from this one”. (virtual function)</p><p id="17f5dd5d-2d97-803c-bb99-f15729dfe595" class=""><mark class="highlight-blue"><code><strong>=0 </strong></code></mark>syntax, pure virtual; that is some class derived from Container must define the function.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-809f-bded-c02cb2c1138c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Container {
public:
	// no such thing as a virtual constructor
	virtual double&amp; operator[](int) = 0; // pure virtual function
	virtual int size() const = 0; // const member function
	virtual ~Container() {} // destructor
};

class Vector_container : public Container {
public:
	Vector_container(int s) : v(s) {}
	~Vector_container() {}
	
	double&amp; operator[](int i) override { return v[i]; } // override is optional, but good practice for compiler to catch mistakes, such as misspellings of function names or function signature
	int size() const override { return v.size(); }
private:
	Vector v;
}; 

Container c; // error: there can be no objects of an abstract class
Container* p = new Vector_container(10); // OK: Container is an interface for Vector_container</code></pre><p id="17f5dd5d-2d97-8047-a8fb-dbc8c1890c6e" class="">
</p><h3 id="17f5dd5d-2d97-8077-9581-d19a7aafb255" class="">Virtual Functions</h3><p id="17f5dd5d-2d97-8003-b93a-c545d464ab62" class="">Implementation technique for compiler is to convert the name of virtual function to an index into a table of pointers to functions. The table is called virtual function table or <mark class="highlight-blue"><code>vtbl</code></mark>.</p><p id="17f5dd5d-2d97-8064-bd2c-e1eeaa5f1524" class="">Derived1 has ptr → <mark class="highlight-blue"><code>vtbl </code></mark>(for Derived1) → points to matching functions.</p><p id="17f5dd5d-2d97-80cd-95ce-d28b6cd47613" class="">Derived2 has ptr → <mark class="highlight-blue"><code><strong>vtbl</strong></code></mark> (for Derived2) → points to matching functions.</p><figure id="17f5dd5d-2d97-80cd-8a35-cc7546bbbe7c" class="image"><a href="image.png"><img style="width:660px" src="image.png"/></a></figure><p id="17f5dd5d-2d97-8079-ae46-c4ac81562156" class="">Space overhead is one pointer in each object with virtual functions plus <mark class="highlight-blue"><code><strong>vtbl</strong></code></mark> for each class.</p><h3 id="17f5dd5d-2d97-8071-a68c-f3eac881e21e" class="">Benefits of Hierarchies</h3><p id="17f5dd5d-2d97-8039-bd64-ed4044a0f8af" class="">Interface Inheritance: Object of derived class can be used whenever an object of base class is required. Example: Container and Shape class, they are abstract classes.</p><p id="17f5dd5d-2d97-806f-9821-f24ff147f241" class="">Implementation Inheritance: Base class provides functions or data that simplifies implementation of derived classes. Smiley’s uses Circle’s constructor.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-806a-a8aa-c0fe340f0f8f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Circle : public Shape {
public:
	Circle(Point p, int rad) : x{p}, r{rad} {} // constructor
private:
	Point x;
	int r;
};

class Smiley : public Circle {
public:
	Smiley(Point p, int rad) : Circle{p, rad}, mouth{nullptr} {}
	~Smiley()
private:
	vector&lt;Shape*&gt; eyes; // use vector&lt;unique_ptr&lt;Shape&gt;&gt; eyes to prevent resource leaks
	Shape* mouth; // use unique_ptr&lt;Shape&gt; mouth to prevent resource leaks
};</code></pre><p id="17f5dd5d-2d97-80b0-a4a6-c628957768b6" class="">Classes in hierarchies - we tend to allocate them on free store using new, and we access them through pointer or references. Note: a virtual destructor is essential for an abstract class because object of derived class is usually manipulated/accessed through the abstract class. In particular it may be deleted through a pointer to base class. Thus, virtual function call <mark class="highlight-yellow_background">ensures the proper destructor is called</mark>. In this case, Smiley’s destructor is called first, then it calls Circle’s destructor.</p><p id="17f5dd5d-2d97-8087-8837-d7b5e6565dce" class="">
</p><p id="17f5dd5d-2d97-8064-a068-feec6f5fd28b" class="">The size of derived class is  its <em>derived class members plus size of base class. </em>See: <a href="https://stackoverflow.com/questions/8813756/inheritance-and-size-of-object">https://stackoverflow.com/questions/8813756/inheritance-and-size-of-object</a></p><h1 id="16c5dd5d-2d97-80e8-aa08-f1d07a9a7810" class="">Chapter 6: Essential Operations</h1><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8069-ae3f-d898116e2bee" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class X {
public:
	X(Sometype); // ordinary constructor
	X(); // default constructor
	X(const X&amp;); // copy constructor
	X(X&amp;&amp;); // move constructor
	X&amp; operator=(const X&amp;); // copy assignment
	X&amp; operator=(X&amp;&amp;); // move assignment 
	~X(); // destructor
};</code></pre><h3 id="16c5dd5d-2d97-8093-aeb4-e755a777230a" class="">=default</h3><p id="16c5dd5d-2d97-802e-b9da-e460f5ddd99d" class="">If you are explicit about some defaults, other default definitions will not be generated.</p><p id="16c5dd5d-2d97-803b-97ce-c3bfde5782cb" class="">If pointer points to something in the class that needs to <strong>delete, </strong>in which case default memberwise copy would be wrong.</p><p id="16c5dd5d-2d97-80bf-91b5-cecb4df7d91b" class="">Rule of Thumb: either define all of the essential operations or none.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-806d-b36f-f100e8830f2c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Y {
public:
	Y(Sometype);
	Y(const Y&amp;) = default; // really want the default copy constructor
	Y(Y&amp;&amp;) = default; // really want the default move constructor
	
};</code></pre><p id="16c5dd5d-2d97-8099-9fdd-c045f292bccc" class="">
</p><h3 id="16c5dd5d-2d97-80f6-a50f-cd2b4a542353" class="">=delete</h3><p id="16c5dd5d-2d97-8034-b0e7-ca541b6c5744" class="">use <mark class="highlight-blue"><code><strong>=delete</strong></code></mark> to indicate that an operation is not to be generated. </p><p id="16c5dd5d-2d97-80a6-a23d-cf74fc8df142" class="">Example: Base class, we don’t want to allow memberwise copy (due to ambiguity).</p><p id="16c5dd5d-2d97-80df-8f3c-ef83de02665c" class=""><mark class="highlight-blue"><code><strong>=delete</strong></code></mark> can be used to “supress” any functions, not just essential member functions</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80fc-9f59-d13d23aa14bb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Shape {
public:
	Shape(const Shape&amp;) = delete; // no copying
	Shape&amp; oeprator=(const Shape&amp;) = delete;
}

void copy(Shape&amp; s1, const Shape&amp; s2) {
	s1 = s2; // compile-time error, Shape copy is deleted
};</code></pre><p id="16c5dd5d-2d97-803b-ae46-f0e9ffce9190" class="">
</p><h3 id="16c5dd5d-2d97-802b-b61b-cfc5f53c71f4" class="">Explicit/Implicit Conversions</h3><p id="16c5dd5d-2d97-80cd-ab67-d9dfdec0f042" class="">A constructor taking single argument defines a conversion from its argument type. Implicit conversion is sometimes ideal, but not always. Define constructor to only allow “explicit” conversion:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8044-a7a4-cd043ccac7c9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Vector {
	explicit Vector(int s) { ... };
};

Vector v1(7); // v1 has 7 elements
Vector v2 = 7; // error! no implicit conversion from int to Vector.
// Without explicit keyword, v2 = 7; OK: v2 has 7 elements</code></pre><p id="16c5dd5d-2d97-8086-b765-d7124a3c40f1" class="">
</p><h3 id="16c5dd5d-2d97-80a9-b92d-fc0bd136d634" class="">Member Initializer</h3><p id="16c5dd5d-2d97-80b1-957f-e1be9e690c63" class="">supply default values which are used whenever constructor doesn’t provide a value.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8070-9aae-c5db34a4bba1" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class complex {
	double re = 0;
	double im = 0;
public:
	complex(double r, double i) : re{r}, im{i} {} // construct complex from 2 scalars {r,i}
	complex(double r) : re{r} {} // construct complex from 1 scalar {r,0}
	complex() {} // default complex {0,0}
}</code></pre><p id="16c5dd5d-2d97-80b4-971f-d3bba1cb9db4" class="">
</p><h3 id="16c5dd5d-2d97-8057-bbee-d985fac167f8" class="">Copying Containers</h3><p id="16c5dd5d-2d97-80e3-9d4e-dfa4e500bcff" class="">When a class is a resource handle (class responsible for object accessed through a <mark class="highlight-yellow_background">pointer</mark>), default memberwise copy is typically a disaster.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80b4-837e-eb401a7d932f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void bad_copy(Vector v1) {
	// using default copy
	Vector v2 = v1;
	v1[0] = 2; // v2[0] is now also 2
	v2[1] = 3; // v1[1] is now also 3
}

// defining better copy semantics

class Vector {
public:
	Vector(int s); // constructor 
	~Vector() { delete[] elem; } // destructor
	
	// copy constructor 
	Vector(const Vector&amp; a) : elem{new double[a.sz]}, sz{a.sz} {
		for (int i = 0; i &lt; sz; ++i) {
			elem[i] = a.elem[i];
		}
	}
	// copy assignment
	Vector&amp; operator=(const Vector&amp; a) {
		double *p = new double[a.sz];
		for (int i = 0; i &lt; a.sz; ++i) {
			p[i] = a.elem[i];
		}
		// elements are copied before old elements are deleted, 
		// so if something wrong goes with the element copy and expection is thrown,
		// old value of Vector is preserved
		
		delete[] elem; // delete old elements
		elem = p;
		sz = a.sz;
		return *this;
	};
	
	double&amp; operator[](int i);
	const double&amp; operator[](int i) const;
	
	int size() const;
private:
	double* elem; // elem points to array of sz doubles;
	int sz;
};</code></pre><p id="16c5dd5d-2d97-8028-9abc-de81d50d2a75" class="">
</p><h3 id="16c5dd5d-2d97-8082-be0c-eb5fca524a0b" class="">Moving Containers</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8005-9249-e2e6b0798231" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Vector operator+(const Vector&amp; a, const Vector&amp; b) {
	Vector res(a.size());
	for (int i = 0; i &lt; a.size(); ++i)
		res[i] = a[i] + b[i];
		return res;
}

void f(const Vector&amp; x, const Vector&amp; y, const Vector&amp; z) { Vector r; r = x+y+z; };
// Note: res is never used again after the copy. Wasteful copy operations!

class Vector {
public:
	// ...
	Vector(const Vector&amp; a); // copy constructor
	Vector&amp; operator=(const Vector&amp; a); // copy assignment
	
	// move constructor
	Vector(Vector&amp;&amp; a) : elem{a.elem}, sz{a.sz} {
		a.elem = nullptr;
		a.sz = 0;
	};
	
	Vector&amp; operator=(Vector&amp;&amp; a); // move assignment
};</code></pre><p id="16c5dd5d-2d97-808c-975b-e08e7d36ac03" class="">Given the definition, compiler will choose move constructor to implement the transfer of return value out of the function. </p><p id="16c5dd5d-2d97-80dd-b557-f946a8efee36" class=""><mark class="highlight-blue"><code><strong>&amp;&amp;</strong></code></mark> means <mark class="highlight-blue"><code><strong>r-value</strong></code></mark> reference, and is a reference to which we bind an <mark class="highlight-blue"><code><strong>rvalue</strong></code></mark>.</p><ul id="16c5dd5d-2d97-80e4-9b38-e0b9273e2593" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>lvalue</strong></code></mark>: something that can appear on LHS of an assignment. (i.e, the name of a variable, a function, a <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">template parameter object</a>(since C++20), or a data member, regardless of type, such as <a href="http://en.cppreference.com/w/cpp/io/cin">std::cin</a> or <a href="http://en.cppreference.com/w/cpp/io/manip/endl">std::endl</a>)</li></ul><ul id="16c5dd5d-2d97-80cb-bc84-f2e5d3b70c10" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>rvalue</strong></code></mark>: a value that you cannot assign to, such as an int returned by function call. Since nobody else can assign to <mark class="highlight-blue"><code><strong>rvalue</strong></code></mark> reference, we can safely “steal” it. <span style="border-bottom:0.05em solid">res in </span><mark class="highlight-blue"><code><strong><span style="border-bottom:0.05em solid">operator+()</span></strong></code></mark><span style="border-bottom:0.05em solid"> for Vectors is such example.</span><ul id="17f5dd5d-2d97-80f6-9364-f3c12d6df8b2" class="bulleted-list"><li style="list-style-type:circle">An <em><mark class="highlight-blue"><code><strong>rvalue</strong></code></mark></em><em> expression</em> is either <mark class="highlight-blue"><code><strong>prvalue</strong></code></mark><mark class="highlight-blue"><strong> </strong></mark><em><mark class="highlight-default"><strong>(may not be polymorphic, such as a literal </strong></mark></em><mark class="highlight-blue"><code><strong>42, true or nullptr</strong></code></mark> <em><mark class="highlight-default"><strong>or function call or or an overloaded operator expression whose return type is non-reference </strong></mark></em><mark class="highlight-blue"><code><strong>it++, str1+str2</strong></code></mark><em><mark class="highlight-default"><strong>)</strong></mark></em> </li></ul><ul id="17f5dd5d-2d97-8037-8d4b-c407acdfd6ff" class="bulleted-list"><li style="list-style-type:circle">or <mark class="highlight-blue"><code><strong>xvalue</strong></code></mark>. <em><mark class="highlight-default"><strong>(may be polymorphic, such as a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as </strong></mark></em><mark class="highlight-blue"><code><strong>std::move(x)</strong></code></mark><em><mark class="highlight-default"><strong>)</strong></mark></em></li></ul></li></ul><p id="16c5dd5d-2d97-8059-8667-e1d2abb19ee2" class="">Move constructor does not take <strong>const </strong>argument, since it is supposed to remove the value from the argument. Move assignment is defined similarly.</p><p id="16c5dd5d-2d97-8066-8afa-ee2643ff0e71" class="">
</p><h3 id="16c5dd5d-2d97-807b-80f0-de6696b4a15e" class="">Copy elision</h3><p id="16c5dd5d-2d97-8065-8276-ce0ae35218b9" class="">Note: Copy elision is compiler optimization that eliminates unnecessary copying of objects. <em>copy-initialization</em> is usually equivalent to <em>direct-initialization</em> in terms of performance, but not in semantics; <em>copy-initialization</em> still requires an accessible (i.e public) copy constructor. </p><p id="16c5dd5d-2d97-807b-aa1c-e02923a5554d" class="">
</p><p id="16c5dd5d-2d97-8057-8979-ee18d4f33098" class="">GCC provides the <code>-fno-elide-constructors</code> option to disable copy-elision. </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80df-a954-e703c54d507b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct C {
	explicit C(int a) { ... };
	C(const C&amp; a) { ... };
};

C c1(42);      // direct-initialization, calls C::C(int)
C c2 = C(42);  // copy-initialization, calls C::C(const C&amp;), but copy is elided (aka omitted)</code></pre><p id="16c5dd5d-2d97-8097-b3ac-c9df5795fa81" class="">
</p><p id="16c5dd5d-2d97-80cd-b421-d18cde56f45e" class="">On the other hand, it is typically not possible to implicitly eliminate copy or move operations from assignments, so move assignments can be critical for performance.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8000-9191-c7be8eacb459" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Vector x(1000), y(2000), z(3000);
z = x; // we get copy assignment
y = std::move(x); // move assignment
// ... better not to use x here onwards</code></pre><p id="16c5dd5d-2d97-8036-81d4-d0734b04c3f0" class="">
</p><h3 id="16c5dd5d-2d97-805a-8367-c2037b64c225" class="">Resource Management &amp; RAII (Resource Acquisition Is Initialization)</h3><p id="16c5dd5d-2d97-802e-8ed7-f2978ab7090e" class="">A resource that is not just memory is called a <em>non-memory resource. </em></p><ul id="16c5dd5d-2d97-8040-beb9-d11e1fc36867" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>Vectors, string, map, unordered_map</strong></code></mark> hold memory, </li></ul><ul id="16c5dd5d-2d97-80ad-8254-d44f875a30cb" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>threads</strong></code></mark> hold system threads</li></ul><ul id="16c5dd5d-2d97-80b1-9f6b-e5079670b2c2" class="bulleted-list"><li style="list-style-type:disc">fstreams (<mark class="highlight-blue"><code><strong>ifstream, ofstream</strong></code></mark>) hold file handles</li></ul><ul id="16c5dd5d-2d97-802e-b16c-f7e45b120c5f" class="bulleted-list"><li style="list-style-type:disc">locks (<mark class="highlight-blue"><code><strong>lock_guard, unique_lock</strong></code></mark>)</li></ul><ul id="16c5dd5d-2d97-807d-885b-fde4c1a45494" class="bulleted-list"><li style="list-style-type:disc">general objects (through <mark class="highlight-blue"><code><strong>unique_ptr</strong></code></mark> and <mark class="highlight-blue"><code><strong>shared_ptr</strong></code></mark>)</li></ul><p id="16c5dd5d-2d97-8014-b533-fb747c3fd35c" class="">Garbage collection is fundamentally a global memory management scheme. Clever implementations can compensate, but as systems are getting more distributed (caches, multicores and clusters) locality is more important than ever.</p><p id="16c5dd5d-2d97-80c2-83a0-e410c4be23b1" class="">
</p><p id="16c5dd5d-2d97-80ef-bedf-ed1227b2a6a0" class="">RAII: We let each resource have an owner in some scope and by default be released at the end of its owner’s scope.</p><p id="16c5dd5d-2d97-80c2-b024-f162747eb27e" class="">
</p><h3 id="16c5dd5d-2d97-80bc-bc1a-cb2f252c098c" class="">Operator Overloading</h3><p id="16c5dd5d-2d97-80ba-95e3-ea72a3d6e83a" class="">Unfortunately, we cannot define the <mark class="highlight-blue"><code><strong>(.)</strong></code></mark> operator dot to get smart references.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80ee-b2b4-d77e1a943ab7" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// operator can be defined as member function, conventionally done for =, -&gt;, (), []
class Matrix {
// ...
	Matrix&amp; operator=(const Matrix&amp; a); // assign a to *this; return reference to *this
}

// alternatively, most operators can be defined as free standing functions. It is convention to define binary operators with symmetric operands (such as A+B == B+A) as free standing functions in the namespace of its class.

namespace NX {
	class Matrix {
	};
	Matrix operator+(const Matrix&amp; m1, const Matrix&amp; m2); // assign m1 to m2 and return sum
	bool operator==(const Matrix&amp; m1, const Matrix&amp; m2);
};</code></pre><p id="16c5dd5d-2d97-80a8-913e-ef82efaa350b" class="">
</p><p id="16c5dd5d-2d97-805e-9011-f7df870306ad" class="">Spaceship operator  <mark class="highlight-blue"><code><strong>&lt;=&gt;</strong></code></mark> By defining <strong>default </strong><mark class="highlight-blue"><code><strong>&lt;=&gt;</strong></code></mark>, all other relational operators are also implicitly defined. If non-default, other relational operators except <mark class="highlight-blue"><code><strong>==</strong></code></mark> and <mark class="highlight-blue"><code><strong>!=</strong></code></mark><mark class="highlight-blue"><strong> </strong></mark>are defined. </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80bb-9d7b-d69ac767c881" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class R {
	auto operator&lt;=&gt;(const R&amp; a) const = default;
};

void user(R r1, R r2) {
	bool b1 = (r1 &lt;=&gt; r2) == 0; // r1 == r2
	bool b2 = (r1 &lt;=&gt; r2) &lt; 0 // r1 &lt; r2 
	bool b3 = (r1 &lt;=&gt; r2) &gt; 0 // r1 &gt; r2
	
	bool b4 = (r1 == r2); // OK: implicitly defined using default &lt;=&gt;
	bool b5 = (r1 != r2); // OK 
	bool b6 = (r1 &lt;= r2); // OK;
}

class R2 {
public:
	int m;
	auto operator&lt;=&gt;(const R2&amp; a) const {
		return a.m == m ? 0 : a.m &lt; m ? 1 : -1;
	}
}

void user(R2 r1, R2 r2) {
	bool b4 = (r1 == r2); bool b5 = (r1 != r2);  // error: no non-default == 
	bool b6 = (r1 &lt;= r2); // OK 
}</code></pre><p id="16c5dd5d-2d97-80ef-88a0-c387c3daad09" class="">
</p><h3 id="16c5dd5d-2d97-8032-927b-e26f1e3f23be" class="">User-defined Literals</h3><p id="16c5dd5d-2d97-80e0-9717-f4ca46893358" class="">Standard-Library Suffixes for Literals</p><table id="16c5dd5d-2d97-8002-bf9f-f36e89690923" class="simple-table"><tbody><tr id="2e490da7-e290-42fb-bb9d-3f061dd18702"><td id="&lt;nN`" class="">&lt;chrono&gt;</td><td id="smDZ" class="">std::literals::chrono_literals</td><td id="`Z:&gt;" class="">h, min, s, ms, us, ns</td><td id="EOGn" class="">123s is 123 seconds</td></tr><tr id="94dd93c1-bd36-4c63-aeeb-22a7375dda77"><td id="&lt;nN`" class="">&lt;string&gt;</td><td id="smDZ" class="">std::literals::string_literals</td><td id="`Z:&gt;" class="">s</td><td id="EOGn" class="">“Surprise!”s is a std::string</td></tr><tr id="77e2ae5b-4f1c-48d0-bbed-c0a4669f0127"><td id="&lt;nN`" class="">&lt;string_view&gt;</td><td id="smDZ" class="">std::literals::string_literals</td><td id="`Z:&gt;" class="">sv</td><td id="EOGn" class=""></td></tr><tr id="16c5dd5d-2d97-80b3-91a0-d42296bbded8"><td id="&lt;nN`" class="">&lt;complex&gt;</td><td id="smDZ" class="">std::literals::complex_literals</td><td id="`Z:&gt;" class="">i, il, if</td><td id="EOGn" class="">12.7i is imaginary so that 12.7i+47 is complex</td></tr></tbody></table><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8044-927e-d81ac6ff498e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// example implementation of imaginary suffix to a complex number
constexpr complex&lt;double&gt; operator&quot;&quot;i(long double arg) {
	return {0, arg};
}</code></pre><p id="16c5dd5d-2d97-80ab-b8a5-fdb0793c1715" class="">
</p><h1 id="16c5dd5d-2d97-806a-9088-e49683a7dc26" class="">Chapter 7: Templates</h1><p id="16c5dd5d-2d97-80d6-a226-f3c776a8038c" class="">Templates are compile-time mechanism, so it incurs no run-time overhead.</p><p id="16d5dd5d-2d97-80b8-854a-e51e01965e03" class="">Templates are used in classes and/or functions, but never in code blocks</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80d4-84f5-ce9162d1c73c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
class Vector {
private:
	T* elem;
	int sz;
public:
	explicit Vector(int s);
	~Vector() { delete[] elem; }
	// ... copy and move operations
	
	T&amp; operator[](int i); // for non-const vectors
	const T&amp; operator[](int i) const; // for const vectors
	int size() const ( return sz; )
};

template&lt;typename T&gt;
Vector&lt;T&gt;::Vector(int s) {
	if (s &lt; 0)
		throw length_error{&quot;Vector constructor: negative size&quot;};
	elem = new T[s];
	sz = s;
}

template&lt;typename T&gt;
const T&amp; Vector&lt;T&gt;::operator[](int i) const {
	if (i &lt; 0 || size() &lt;= i)
		throw out_of_range{&quot;Vector::operator[]&quot;};
	return elem[i];
}</code></pre><p id="16c5dd5d-2d97-80f7-bc39-eca08774a40a" class="">
</p><p id="16c5dd5d-2d97-80ee-8ba0-e85c6ee7bd87" class="">To support range-for loop for custom Vector, we need to define <mark class="highlight-blue"><code><strong>begin()</strong></code></mark> and <mark class="highlight-blue"><code><strong>end()</strong></code></mark> functions:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80e5-91fa-ce3cbd49b274" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
T* begin(Vector&lt;T&gt;&amp; x) {
	return &amp;x[0];
}

template&lt;typename T&gt;
T* end(Vector&lt;T&gt;&amp; x) {
	return &amp;x[0] + x.size();
}

void write(Vector&lt;string&gt;&amp; vs) {
	for (auto &amp;s : vs)
		cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;
}</code></pre><p id="16c5dd5d-2d97-8024-896c-c7d6d410aea3" class="">
</p><h3 id="16c5dd5d-2d97-8004-8ab9-c1c56e0c0c92" class="">Value template arguments</h3><p id="16c5dd5d-2d97-801d-8edf-f8050dbb98ba" class="">Useful in many contexts, for example, Buffer allows us to create arbitrarily sized buffers with no use of heap. </p><p id="16c5dd5d-2d97-802d-80fd-d2006f4586df" class="">Note: string literal cannot be template value argument. </p><ul id="16c5dd5d-2d97-8057-9c03-c5e7218f0b5d" class="bulleted-list"><li style="list-style-type:disc">Error: template&lt;string S&gt;</li></ul><ul id="16c5dd5d-2d97-8014-8879-cf1029da1cef" class="bulleted-list"><li style="list-style-type:disc">Workaround is <mark class="highlight-blue"><code><strong>template&lt;char* s&gt;</strong></code></mark></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80b0-89a9-e4b3be4cc179" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T, int N&gt;
struct Buffer {
	constexpr int size() { return N; }
	T elem[N];
}
Buffer&lt;char, 1024&gt; buf; // buffer of characters statically allocated (on the stack)</code></pre><p id="16c5dd5d-2d97-8025-bcac-d26066456ae0" class="">
</p><h3 id="16c5dd5d-2d97-8064-8a9d-f42b7306f03a" class="">Template Argument Deduction</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-801a-a41f-c836a3ca5bb6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Vector&lt;string&gt; vs {&quot;Hello&quot;, &quot;World&quot;}; // OK: Vector&lt;string&gt;

Vector vs1 {&quot;Hello&quot;, &quot;World&quot;};
// OK: deduces to Vector&lt;const char*&gt; C-style string literal is const char*

Vector vs2 {&quot;Hello&quot;s, &quot;World&quot;s}; // OK: deduces to Vector&lt;string&gt;

Vector vs2 {&quot;Hello&quot;s, &quot;World&quot;}; // error: initalizer list is not homogenous</code></pre><p id="16c5dd5d-2d97-808f-889d-c1b3d551ec6e" class="">To resolve ambiguity, we can use concepts (C++ 20). Before that, when dealing with Vectors, we can use deduction guide to say “a pair of the same type should be considered iterators”.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-80e3-8d9a-e47e1d2c4684" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
class Vector {
public:
	Vector(initializer_list&lt;T&gt;); // initializer list constructor
	
	template&lt;typename Iter&gt;
		Vector(Iter b, Iter e) -&gt; Vector&lt;typename Iter::value_type&gt;
		// standard method is (iterator_traits)
		// Vector(Iter b, Iter e) -&gt; Vector&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;
		
	struct iterator { using value_type = T; /* .. */ }; // specified value type = T
	iterator begin();
};

Vector v1 {1,2,3,4,5} // element type is int
Vector v2(v1.begin(), v1.begin()+2); // pair of iterators, element type is int
Vector v3{v1.begin(), v1.begin()+2}; // element type is Vector::iterator</code></pre><p id="16c5dd5d-2d97-800f-a76d-d870a7639635" class="">{ } initializer syntax always prefers the <mark class="highlight-blue"><code><strong>initializer_list</strong></code></mark> constructor (if present), so v3 is a vector of iterators, <mark class="highlight-blue"><code><strong>Vector&lt;Vector&lt;int&gt;::iterator&gt; </strong></code></mark></p><p id="16c5dd5d-2d97-8094-a28d-d7c6fa144fdc" class="">
</p><h3 id="16c5dd5d-2d97-804d-a92d-f63f9eab9aca" class="">Function Templates</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16c5dd5d-2d97-8094-be1a-c86c190987f8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// function can have templates too
template&lt;typename S, typename V&gt;
V sum(const Sequence&amp; s, Value v) {
	for (auto x : s)
		v += x;
	return v;
};</code></pre><p id="16c5dd5d-2d97-80a5-845d-d627df9f060b" class="">Function template can be a member function, but <mark class="highlight-yellow_background">not virtual members</mark>, since compiler would not know all instantiations of such a template in the program, so it could not generate a <code>vtbl</code>.</p><p id="16c5dd5d-2d97-80d5-9a66-f6b63c837f91" class="">
</p><h3 id="16c5dd5d-2d97-80ee-b223-c9930cf87fe4" class="">Function Objects (aka Functors)</h3><p id="16c5dd5d-2d97-808e-bbd3-e0f36836ad69" class="">Function objects used to specify meaning of key operations of a general algorithm (such as <mark class="highlight-blue"><code><strong>Less_than</strong></code></mark> for <mark class="highlight-blue"><strong>count()</strong></mark>) are sometimes referred to as <em>policy objects</em>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80df-95c5-fcfe4d4a6c91" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
class Less_than {
	const T val;
public:
	Less_than(const T&amp; v) : val{v} {}
	bool operator()(const T&amp; x) const { return x&lt;val; } // call operator
}

template&lt;typename C, typename P&gt;
int count(const C&amp;c, P pred) {
	int cnt = 0;
	for (auto &amp;x : c)
		if (pred(x))
			++cnt;
	return cnt;
}

const Vector&lt;int&gt;&amp; vec{1,2,3,4,5};
int x = 5;
cout &lt;&lt; &quot;number of values less than &quot; &lt;&lt; x &lt;&lt; &quot;: &quot; &lt;&lt; count(vec, Less_than{x});</code></pre><p id="16d5dd5d-2d97-80bc-a917-fb6616221156" class="">
</p><h3 id="16d5dd5d-2d97-800f-96a7-d4be418d86d6" class="">Lambda Expressions</h3><ul id="16d5dd5d-2d97-80ea-9c24-c5066b2701a6" class="bulleted-list"><li style="list-style-type:disc">capture list, Capture nothing is <mark class="highlight-blue">[], </mark>all local names by reference is <mark class="highlight-blue"><strong>[&amp;]</strong></mark>, all local names by value is <mark class="highlight-blue"><strong>[=]</strong></mark>, Capture only x by reference is <mark class="highlight-blue"><strong>[&amp;x]</strong></mark>, only copy of (by value) x is<mark class="highlight-blue"><strong> [x]</strong></mark>. For lambda defined within member function, <mark class="highlight-blue"><strong>[this]</strong></mark> captures object by reference,<mark class="highlight-blue"><strong> [*this]</strong></mark> captures copy of (by value) object .</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8060-a653-d2b576461383" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void fn(const list&lt;string&gt;&amp; lst, const string&amp; s) {
	cout &lt;&lt; &quot;number of values less than &quot; &lt;&lt; s &lt;&lt; &quot;: &quot; &lt;&lt; 
	count(lst, [&amp;](const string&amp; a) { return a&lt;s });
};

// perform updates by pass by reference
vector&lt;unique_ptr&lt;Shape&gt;&gt; v;
for_each(v, [](unique_ptr&lt;Shape&gt;&amp; ps){ ps-&gt;rotateBy(45); }); // note arg is non const</code></pre><p id="16d5dd5d-2d97-8069-a104-c7d11a1b7596" class="">
</p><p id="16d5dd5d-2d97-804f-87b1-c532a7abb6e1" class="">We can use lambda with <mark class="highlight-blue"><code><strong>auto</strong></code></mark> parameter, known as a <em>generic lambda. </em>We can further constrain the parameter using concepts (i.e define Pointer_to_class to require <mark class="highlight-blue"><strong>*</strong></mark> and <mark class="highlight-blue"><strong>→</strong></mark> and <mark class="highlight-blue"><strong>write</strong></mark>)</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8053-9f5d-d0d2200f4fb2" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// consider simplified for-each
for_each(v, [](auto&amp; ps){ ps-&gt;rotateBy(45); });
for_each(v, [](Pointer_to_class auto&amp; ps){ ps-&gt;rotateBy(45); ps-&gt;draw(); });</code></pre><p id="16d5dd5d-2d97-80e0-ae5f-d63df4e91697" class="">
</p><h3 id="16d5dd5d-2d97-80c7-a77d-f18160c0d491" class="">Finally()</h3><p id="16d5dd5d-2d97-800d-85e0-f77d149a7a2c" class="">Use <mark class="highlight-blue"><code><strong>finally()</strong></code></mark> to provide RAII for types without destructors that require “cleanup operations”.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80e2-aba5-d800fc3baf7a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void old_style(int n) {
	void* p  = malloc(n*sizeof(int));
	auto act = finally([&amp;]{ free(p); }); // call lambda upon scope exit
	// p is implicity freed upon scope exit
}</code></pre><blockquote id="16d5dd5d-2d97-80e8-8176-f336a1405462" class=""><mark class="highlight-blue"><code><strong>[[nodiscard]]</strong></code></mark> : Attributes (introduced in C++17) to member functions to highlight at compile time which return values should not be ignored.</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8013-8cf9-d2a4f2920ff8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// sample implimentation of finally
template&lt;class F&gt;
[[nodiscard]] auto finally(F f) {
	return Final_action{f};
}

template&lt;class F&gt;
struct Final_action {
	explicit Final_action(F f) : act{f} {}
	~Final_action() { act(); }
	F act;
};</code></pre><p id="16d5dd5d-2d97-8033-bfed-fdb3f8661433" class="">
</p><h3 id="16d5dd5d-2d97-80ae-bcaf-fd0886ce8667" class="">Template Mechanisms (Variable Templates, Aliases, Compile-Time if)</h3><ul id="16d5dd5d-2d97-8035-8f94-ff4807286dc4" class="bulleted-list"><li style="list-style-type:disc">Variable Templates: often used as constants. STL uses variable templates to implement math constants like <mark class="highlight-blue"><code><strong>pi</strong></code></mark> and <mark class="highlight-blue"><code><strong>log2e</strong></code></mark>.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8036-b1d0-e903f8dd6fe7" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;class T&gt;
	constexpr T viscosity = 0.4; // viscosity is of type T

auto vis2 = 2*viscosity&lt;double&gt;;

template&lt;class T&gt;
	constexpr vector&lt;T&gt; external_acc = {T{}, T{-9.8}, T{}}; // external_acc is a vec of T

auto acc = external_acc&lt;float&gt;; </code></pre><ul id="16d5dd5d-2d97-8037-ac95-f2d52cf6f444" class="bulleted-list"><li style="list-style-type:disc">Aliases</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80d9-8aad-c19514d4fccd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">using size_t = unsigned int;

template&lt;typename C&gt;
using Value_type = C::value_type;

template&lt;Container C&gt;
void algo(Conatiner&amp; c) {
	Vector&lt;Value_type&lt;Container&gt;&gt; vec; // if Container is list&lt;int&gt;, then the value_type is int, so vec is Vector&lt;int&gt;
}

template&lt;typename Value&gt;
using String_map = map&lt;string, Value&gt;;

String_map&lt;int&gt; m;</code></pre><ul id="16d5dd5d-2d97-8083-8f90-e0673159624c" class="bulleted-list"><li style="list-style-type:disc">Compile-time if: The compiler checks only the selected branch of an <mark class="highlight-blue"><code><strong>if constexpr</strong></code></mark>, offering optimal performance and locality of optimization.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8039-a4af-f5481bcc8885" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
void update(T&amp; target) {
	if constexpr(is_trivially_copyable&lt;T&gt;)
		simple_and_fast(target); // never put try-catch in the if block
	else
		slow_and_safe(target);
}</code></pre><p id="16d5dd5d-2d97-8066-9bfa-d07e90899bc9" class="">
</p><h1 id="16d5dd5d-2d97-80e7-b234-f196b46417d5" class="">Chapter 8: Concepts and Generic Programming</h1><p id="16d5dd5d-2d97-80f6-81da-d0595bea32bb" class="">A concept is a <strong>compile-time predicate</strong> specifying how one or more types can be used. Note that when defining a concept, <code>a non-template variable cannot be ‘concept’</code></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8025-910c-d0b14e2f2615" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T, typename T2 = T&gt;  // required
concept Equality_comparable = 
	requires (T a, T2 b) {
		{ a == b } -&gt; std::convertible_to&lt;bool&gt;; // must be able to compare T to T2 with ==
		{ a != b } -&gt; std::convertible_to&lt;bool&gt;; // compare T to T2 with !=
		{ b == a } -&gt; std::convertible_to&lt;bool&gt;; // must be able to compare T2 to T with ==
		{ b != a } -&gt; std::convertible_to&lt;bool&gt;; // compare T2 to T with !=
	}
	
	static_assert(Equality_comparable&lt;int, double&gt;); // OK
	static_assert(Equality_comparable&lt;int&gt;); // OK
	static_assert(Equality_comparable&lt;int, string&gt;); // compile-error, assertion fails
	
	struct S { int a };
	static_assert(Equality_comparable&lt;S&gt;); // compile-error, assertion fails</code></pre><p id="16d5dd5d-2d97-800f-82ec-c82c5e16b302" class="">The <mark class="highlight-blue"><code><strong>typename T2 = T</strong></code></mark> says that if we don’t specify the second template argument, then default is T.</p><p id="16d5dd5d-2d97-8032-865a-d563c75166eb" class="">
</p><p id="16d5dd5d-2d97-80f1-b978-c3040a0a9e0a" class="">Most template arguments require specific requirements for code to compile properly and generated code to work properly. We can use concepts to constrain templates.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-808d-a56a-c80286320019" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;Sequence Seq, Number Num&gt; 
	requires Arithmetic&lt;range_value_t&lt;Seq&gt;,Num&gt; // requirements clause
Num sum(Seq s, Num n);
	
//verbose way of writing
template&lt;typename Seq, typename Num&gt; 
	requires Sequence&lt;Seq&gt; &amp;&amp; Number&lt;Num&gt; &amp;&amp; Arithmetic&lt;range_value_t&lt;Seq&gt;, Num&gt;</code></pre><p id="16d5dd5d-2d97-80fc-a785-e109389b9fca" class=""><mark class="highlight-blue"><strong>Requires-expression</strong></mark> is a predicate that evaluates to true if the statements in the code are valid and false if not, usually not seen in ordinary code. They belong in the implementation of abstractions. If you see <mark class="highlight-blue"><code><strong>requires requires</strong></code></mark> in your code, it is probably too low level.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8008-9eed-d7848c8a36d6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// example of requires expression.
requires(Iter p, int i) { p[i]; p+i; }

template&lt;forward_iterator Iter&gt;
	requires x
void advance(Iter p, int n) { p+=n; }</code></pre><p id="16d5dd5d-2d97-8095-8ff5-fc35f39de8fe" class="">
</p><p id="16d5dd5d-2d97-80d5-a942-fbf8785c3c56" class="">Consider the implementation of Sequence:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8077-82e1-f91d8d33d36f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template &lt;typename S&gt;
concept Sequence = input_range&lt;S&gt;; // using STL concept input_range

// implementation 
template &lt;typename S&gt;
concept Sequence = requires(S a) {
	typename range_value_t&lt;S&gt;; // S must have valid value type &#x27;t&#x27; stands for type
	typename iterator_t&lt;S&gt;; // S must have valid iterator type &#x27;t&#x27; stands for type
	{ a.begin() } -&gt; same_as&lt;iterator_t&lt;S&gt;&gt;; // begin() that returns iterator
	{ a.end() } -&gt; same_as&lt;iterator_t&lt;S&gt;&gt;;
	
	requires input_iterator&lt;iterator_t&lt;S&gt;&gt;; // S&#x27;s iterator must be input iterator
	requires same_as&lt;range_value_t&lt;S&gt;, iter_value&lt;S&gt;&gt;;
};</code></pre><p id="16d5dd5d-2d97-80b3-9d6f-e6a0df45ab41" class="">
</p><p id="16d5dd5d-2d97-8097-9af8-ce8b341c226f" class="">Check of template definition only occurs at the time of instantiation (late into the compilation process). This allows for incomplete concepts during development, and debugging a template without affecting its interface.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80bf-bbf1-f9980703c537" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;equality_comparable T&gt;
bool cmp(T a, T b) { return a &lt; b; }

bool b0 = cmp(cout,cerr); // error: ostream doesnt support ==</code></pre><p id="16d5dd5d-2d97-80f0-99b2-f4d9d8622226" class="">
</p><h3 id="16d5dd5d-2d97-807d-a8cf-f7b8c5ad464d" class="">Auto</h3><p id="16d5dd5d-2d97-80b7-a250-c7bf5a4eac10" class="">Remember that <mark class="highlight-blue"><code><strong>auto</strong></code></mark> can be used to indicate that the object should have the type of its initializer.</p><ol type="1" id="16d5dd5d-2d97-80a3-8897-e66bf7b93b6c" class="numbered-list" start="1"><li>Concepts can be used for constraining function arguments.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80da-9fe5-f850395fc8cb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">auto twice(Arithmetic auto x) { return x+x; }; // just for numbers
string s = &quot;Hello&quot;;
auto x2 = twice(s); // error: a string is not Arithmetic

// Note that auto keyword is still needed
auto twice(Arithmetic auto x); // OK
auto twice(Arithmetic x); // error: &#x27;auto&#x27; required after concept name</code></pre><p id="17f5dd5d-2d97-8008-97a2-c1ace8cacac8" class="">This code is valid using C++20: This is a special case of <em>unconstrained auto parameter</em>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-809a-8fa2-cc61b21bea98" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int function(auto data) { ... } // do something, there is no constraint on data</code></pre><ol type="1" id="16d5dd5d-2d97-8086-8800-d5d49a16d48c" class="numbered-list" start="2"><li>Concepts can constrain the initialization of variables.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80ee-81d4-cd0eff9dc582" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Arithmetic auto ch2 = open_channel(&quot;foo&quot;); // error: return value is not Arithmetic</code></pre><ol type="1" id="16d5dd5d-2d97-80b4-95b4-c6f45f412c22" class="numbered-list" start="3"><li>Concepts can constrain the return type, which improves readability and debugging.</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-809b-bb1a-c172270815ab" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Number auto fn(int x) { 
	//...
	return fct(x); // an error, unless fct(x) returns Number
}

// alternatively
auto fn(int x) { ... };
Number auto y = fn(x);</code></pre><p id="17f5dd5d-2d97-8056-bf62-d812a27cca7c" class="">
</p><h3 id="16d5dd5d-2d97-80e8-ba71-d5cb65a7562f" class="">Variadic Templates</h3><p id="16d5dd5d-2d97-80bc-9e05-f5449010ebec" class="">Defined to accept an arbitrary number of arguments of arbitrary types. Traditional implementation has been to separate the first argument from the rest then recursively call the template for tail arguments.</p><p id="16d5dd5d-2d97-80ba-a995-f86223f850cb" class="">
</p><p id="16d5dd5d-2d97-80d3-a07b-da02f6f16926" class="">Parameter declared with … is called a <em>parameter pack. </em></p><p id="16d5dd5d-2d97-806a-9bc8-f61fa77fa871" class="">Here tail<strong> is a function argument parameter pack, where elements are of the types found in the template argument parameter pack Tail.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80db-8265-e1aed401209b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
concept Printable = requires(T t) { std::cout &lt;&lt; t; }

template&lt;Printable T, Printable... Tail&gt;
void print(T head, Tail... tail) {
	cout&lt;&lt;head&lt;&lt;&#x27;&#x27;;
	if constexpr(sizeof...(tail)&gt; 0) // to prevent the zero argument case
		print(tail...);
}</code></pre><p id="16d5dd5d-2d97-805d-9944-f38071d3a8a8" class="">
</p><h3 id="16d5dd5d-2d97-80ba-a2de-f19be583cc28" class="">Fold expressions </h3><p id="16d5dd5d-2d97-8037-9078-fad40c94e3ed" class="">For simple variadic templates, can iterate over elements of the parameter pack.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8095-b176-d5c1974ee20d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// rightfold implementation (v[0] + (v[1] + ( v[2] + ... (v[n-1] + 0))))
template&lt;Number... T&gt;
int sum(T... v) {
	return (v + ... + 0); // add all elements of v starting from 0
}

// leftfold implementation ((((0 + v[0]) + v[1]) + v[2]) + ... ) + v[n-1])
template&lt;Number... T&gt;
int sum(T... v) {
	return (0 + ... + v); // all all elements of v to 0
}

// leftfold implementation
template&lt;Printable... T&gt;
void print(T&amp;&amp; args) {
	(std::cout&lt;&lt; ... &lt;&lt; args) &lt;&lt;&#x27;\n&#x27;
}</code></pre><p id="16d5dd5d-2d97-8021-ad17-ead3cc50b3f7" class="">
</p><h3 id="16d5dd5d-2d97-8066-a1e3-c5d807dc0c6b" class="">Template Compilation Model</h3><p id="16d5dd5d-2d97-8026-9767-c2b52c943db8" class="">To use an unconstrained template, its definition (not just its declaration) must be in scope at its point of use. When using header files and <mark class="highlight-blue"><code><strong>#include</strong></code></mark>, this means template definitions are found in header files, not in <mark class="highlight-blue"><code><strong>.cpp</strong></code></mark> files. For example, standard header <mark class="highlight-blue"><code><strong>&lt;vector&gt;</strong></code></mark> holds the definition of vector.</p><p id="16d5dd5d-2d97-80bb-a431-da49381318a1" class="">
</p><h1 id="16d5dd5d-2d97-8047-9230-dd0dd9016caa" class="">Chapter 9: STL Overview</h1><h3 id="16d5dd5d-2d97-8032-93ab-fbaa7f799618" class="">The range namespace</h3><p id="16d5dd5d-2d97-8004-9bda-e8cb54a762e8" class="">STL offers algorithms like sort() and copy(), int two versions:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80d5-a448-d0864b9b85fa" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">using namespace std;
using namespace ranges;

void f(vector&lt;int&gt;&amp; v) {
	sort(v.begin(), v.end()); // error: ambiguous
	sort(v); // error: ambiguous
}

// to protect against ambiguities, introduce range version of STL into a scope
using namespace std;

void g(vector&lt;int&gt;&amp; v) {
	sort(v.begin(), v.end()); // OK
	ranges::sort(v); // OK
	using ranges::sort;
	sort(v); // OK
}</code></pre><p id="16d5dd5d-2d97-803b-b294-d867c13d4264" class="">
</p><h1 id="16d5dd5d-2d97-8010-a12e-df28c9639a61" class="">Chapter 10: Strings and Regular Expressions</h1><p id="16d5dd5d-2d97-805b-8d6c-e02afd2ad1da" class="">By default definition, string literal is <mark class="highlight-blue"><code><strong>const char*</strong></code></mark>. To get a literal of type <mark class="highlight-blue"><code><strong>std::string</strong></code></mark>, use a “s” suffix. You need to use the namespace <mark class="highlight-blue"><code><strong>std::literals::string_literals</strong></code></mark>. </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-802c-81a8-e813efb85fc1" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">string name = &quot;Niels Stroustrup&quot;;
string s = name.substr(6,10); // s = &quot;Stroustrup&quot; start at idx 6, length 10
name.replace(0,5,&quot;nicholas&quot;); // name = &quot;nicholas Stroustrup&quot; start at idx 0, length 5
name[0] = toupper(name[0]); // name = &quot;Nicholas Stroustrup&quot;

// if you need C-style string
printf(&quot;For people who like printf %s\n&quot;, s.c_str()); // s.c_str() returns pointer to s&#x27;s characters</code></pre><p id="16d5dd5d-2d97-803c-a1be-e1905e1a810f" class="">
</p><h3 id="16d5dd5d-2d97-806f-a7fb-cb4b22f1df9c" class="">String Implementation</h3><p id="16d5dd5d-2d97-80e4-82f1-cd7f985372c2" class="">These days, string is usually implemented using the <em>short-string optimization</em>. Short string values (usually about 14 chars) are kept in the string object itself, only longer strings are placed on the free store. Especially in multi-threaded implementations memory allocation can be costly.</p><p id="16d5dd5d-2d97-807a-8926-f8ff1a5715da" class="">When string value changes from short to long/long to short, it adjusts appropriately. </p><p id="1795dd5d-2d97-80bd-a05f-ffd6e5c5624a" class="">
</p><p id="16d5dd5d-2d97-80d3-8b81-dc49544b60a9" class="">Another implementation/optimization is copy on write, but could be problematic in multithreaded programs. See:  <a href="https://stackoverflow.com/questions/1466073/how-is-stdstring-implemented">https://stackoverflow.com/questions/1466073/how-is-stdstring-implemented</a></p><h3 id="16d5dd5d-2d97-80f6-8e47-d77b391afb06" class="">String View</h3><p id="16d5dd5d-2d97-8067-b41d-daf3e414284e" class=""><mark class="highlight-blue"><code><strong>string_view</strong></code></mark> gives access to a contiguous sequence of characters (can be string, C-style string, etc). Think of <mark class="highlight-blue"><code><strong>string_view</strong></code></mark> as a pointer to “read-only” view of its characters, and for <mark class="highlight-blue"><code><strong>string_view</strong></code></mark> to be used, it must point to something.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8001-9a88-c901f532ddff" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">using namespace std::literals::string_view_literals; // to use the sv suffix

string cat(string_view sv1, string_view sv2) {
	string res{sv1};
	return res += sv2;
}

string king = &quot;Harold&quot;;
auto s1 = cat(&quot;Edward&quot;, &quot;Stephen&quot;sv); // OK, const char* and string_view
auto s2 = cat({&amp;king[0],2}, {&amp;king[2],4}); // OK</code></pre><p id="16d5dd5d-2d97-807a-8e5f-de0270a60d67" class="">By using <mark class="highlight-blue"><code><strong>sv</strong></code></mark> suffix, the length is computed at compile time, as compared to <mark class="highlight-blue"><code><strong>const char *</strong></code></mark><mark class="highlight-blue"> </mark>that requires counting of characters. </p><h1 id="16d5dd5d-2d97-8024-96d9-cb56f72d3b7b" class="">Chapter 11: Input and Output</h1><p id="16d5dd5d-2d97-8025-9b78-eddd6fe4df28" class=""><mark class="highlight-blue"><code><strong>ostream </strong></code></mark>converts typed objects to stream of chars (bytes)</p><p id="16d5dd5d-2d97-80ac-a0d3-cab818b972a8" class=""><mark class="highlight-blue"><code><strong>istream</strong></code></mark> converts a stream of chars (bytes) to typed objects</p><p id="16d5dd5d-2d97-8070-9f49-f686a4a78e85" class="">I/O stream classes have destructors that free all resources owned (i.e buffers and file handles). They are example of RAII.</p><p id="16d5dd5d-2d97-8029-99f1-f83dfdc89667" class="">
</p><p id="16d5dd5d-2d97-8007-8767-cc05eeb6ec94" class="">By default, a whitespace character, such as a space or newline, terminates the read, so:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80dd-b2b6-f513c91415f4" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">cout&lt;&lt;&quot;Please enter your name\n&quot;;
string str; // if input is Eric Bloodaxe, only Eric will be cin
cin&gt;&gt;str;
cout&lt;&lt;&quot;Hello, &quot;&lt;&lt;str&lt;&lt;&quot;!\n&quot;; // Hello, Eric!

// You can read a whole line using the getline function
cout&lt;&lt;&quot;Please enter your name\n&quot;;
string str;
getline(cin,str);
cout&lt;&lt;&quot;Hello, &quot;&lt;&lt;str&lt;&lt;&quot;!\n&quot;;</code></pre><p id="16d5dd5d-2d97-8052-8363-fbbc10a5fa71" class="">
</p><h3 id="16d5dd5d-2d97-8090-bd4e-d1f4e0be0867" class="">iostream</h3><p id="16d5dd5d-2d97-8098-aa69-f46c57cc711c" class=""><mark class="highlight-blue"><code><strong>is&gt;&gt;i </strong></code></mark>returns a reference to <mark class="highlight-blue"><code><strong>is</strong></code></mark>, and iostream yields true if the stream is ready for another operation. In this case, <mark class="highlight-blue"><code><strong>is</strong></code></mark><mark class="highlight-blue"><strong> </strong></mark>will read until something that is not an int is encountered.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80f9-915d-e295b2d3e7c8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">vector&lt;int&gt; read_ints(istream&amp; is) {
	vector&lt;int&gt; res;
	for (int i; is&gt;&gt;i; ) 
		res.push_back(i);
	return res;
}

vector&lt;int&gt; read_ints(istream&amp; is, const string&amp; terminator) {
	vector&lt;int&gt; res;
	for (int i; is&gt;&gt;i; )
		res.push_back(i);
	if (is.eof()) // fine: end of file
		return res;
	if (is.fail()) // failed to read an int, was is the string terminator?
		is.clear(); // reset state to good()
		string s;
		if (is&gt;&gt;s &amp;&amp; s==terminator)
			return res;
		is.setstate(ios_base::failbit); // add fail() to is&#x27;s state
}

auto v = read_ints(cin, &quot;stop&quot;);</code></pre><p id="16d5dd5d-2d97-80b3-a479-cccd7b345432" class="">
</p><h3 id="16d5dd5d-2d97-80bf-a5f6-e4544a50ea34" class="">I/O Streams of User Defined Types</h3><p id="16d5dd5d-2d97-801b-8cf4-fa6011442285" class="">User-defined output operator takes its output stream by reference as first argument, and returns it as result.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8032-a441-de24bba48595" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Entry {
	string name;
	int number;
};

ostream&amp; operator&lt;&lt;(ostream&amp; os, const Entry&amp; e) {
	return os &lt;&lt; &quot;{\&quot;&quot; &lt;&lt; e.name &lt;&lt; &quot;\&quot;, &quot; &lt;&lt; e.number &lt;&lt; &quot;}&quot;;
}</code></pre><p id="16d5dd5d-2d97-8015-9f76-e25d201a7add" class="">User-defined input operator is more complicated because it has to check for correct formatting and deal with errors.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8025-ab3b-dd36278bb4cb" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// for example, read {&quot;sample name&quot;, 12345}

istream&amp; operator&gt;&gt;(istream&amp; is, const Entry&amp; e) {
	char c, c2;
	if (is&gt;&gt;c &amp;&amp; c==&#x27;{&#x27; &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2==&#x27;&quot;&#x27;) {
		string name;
		while(is.get(c) &amp;&amp; c!=&#x27;&quot;&#x27;) // we use is.get(c) instead of is&gt;&gt;c as the latter skips over whitespaces (tabs, spaces, newlines), but former does not
			name+=c;
		if(is&gt;&gt;c &amp;&amp; c==&#x27;,&#x27;) { // here we use cin&gt;&gt;c to ignore whitespaces
			int number = 0;
			if (is&gt;&gt;number&gt;&gt;c &amp;&amp; c==&#x27;}&#x27;)
				e = {name,number};
				return is;
		}
	}
	
	is.setstate(ios_base::failbit); // register the failure in the stream;
	return is;
}

// example
{  &quot;John Marwoord Cleese&quot;, 123456      }
for (Entry ee; cin&gt;&gt;ee; )
	cout &lt;&lt; ee &lt;&lt; &#x27;\n&#x27;; // write ee to cout, {&quot;John Marwoord Cleese&quot;, 123456} formatted</code></pre><p id="16d5dd5d-2d97-8021-a65c-dc4b8aaba74f" class="">
</p><h3 id="16d5dd5d-2d97-809e-81f4-e7adf6def964" class="">Stream Formatting</h3><p id="16d5dd5d-2d97-8024-96bf-f06116c21fb4" class="">The simplest forms of formatting controls are called <em>manipulators</em> and are found in <mark class="highlight-blue"><code><strong>&lt;ios&gt;, &lt;istream&gt;, &lt;ostream&gt;, &lt;iomanip&gt;.</strong></code></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80fc-b5bb-e40798f889cc" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">cout&lt;&lt;1234&lt;&lt;&#x27; &#x27;&lt;&lt;hex&lt;&lt;1234&lt;&lt;&#x27; &#x27;&lt;&lt;oct&lt;&lt;1234&lt;&lt;&#x27; &#x27;&lt;&lt;dec&lt;&lt;1234&lt;&lt;&#x27;\n&#x27;; // 1234 4d2 2322 1234</code></pre><p id="16d5dd5d-2d97-8019-a213-d71d77ad6b69" class="">We can explicitly set the output format for floating point numbers.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8042-b12b-fb72129d9136" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">constexpr double d = 123.456;
cout&lt;&lt;d&lt;&lt;&quot;;&quot;
		&lt;&lt;scientific&lt;&lt;d&lt;&lt;&quot;; &quot; // 1.234560e+02; (normalized - 1 digit before exponent)
		&lt;&lt;hexfloat&lt;&lt;d&lt;&lt;&quot;; &quot;
		&lt;&lt;fixed&lt;&lt;d&lt;&lt;&quot;; &quot; // 123.456000; precision specifies the max number of digits
		&lt;&lt;defaultfloat&lt;&lt;d&lt;&lt;&quot;;\n&quot;; // 123.456; lets the implementation choose the format
		
// 123.456; 1.234560e+02; 0x1.edd2f1a9fbe77p+6; 123.456000; 123.456;</code></pre><p id="16d5dd5d-2d97-809d-b970-f7520d358fa1" class="">With <mark class="highlight-blue"><code><strong>precision()</strong></code></mark>, floating-point values are rounded, not truncated. <mark class="highlight-blue"><code><strong>precision()</strong></code></mark> doesn’t affect int.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8068-9c16-e89d93808b07" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">cout.precision(8);
cout&lt;&lt;1234.56789&lt;&lt;&#x27; &#x27;&lt;&lt;123.456&lt;&lt;&#x27; &#x27;&lt;&lt;123456&lt;&lt;&#x27;\n&#x27;;
// 1234.5679 123.456 123456</code></pre><p id="16d5dd5d-2d97-805b-8f61-e4c2445674f2" class="">
</p><h3 id="16d5dd5d-2d97-8026-a53b-e8efad8933dd" class="">Format()</h3><p id="16d5dd5d-2d97-80b7-bc3d-e39a7fb5720c" class="">STL provides type-safe, <mark class="highlight-blue"><code><strong>printf()</strong></code></mark> style formatting.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80e5-a9be-f6242c70f9e0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;format&gt;
int val = 127;
string s = format(&quot;Hello, {}\n&quot;, val);
cout&lt;&lt;s; // Hello, 127
cout&lt;&lt; format(&quot;{} {:x} {:o} {:d} {:b}\n&quot;, 1234,1234,1234,1234,1234);

// The number before the : allows us to switch up order/format argument more than once
cout&lt;&lt; format(&quot;{0:} {0:x} {0:o} {0:d} {0:b}\n&quot;, 1234); 
// 1234 4d2 2322 1234 10011010010

// for floating point formats, e for scientific, a for hexfloat, f for fixed, g for default
cout&lt;&lt; format(&quot;{0:} {0:e} {0:a} {0:f} {0:g}\n&quot;, 123.456); 

// precision specifier
cout &lt;&lt; format(&quot;{:.8} {:.4} {}\n&quot;, 1234.56789, 1234.56789, 123456);</code></pre><p id="16d5dd5d-2d97-802e-a0e9-c47f4d06ed65" class="">
</p><h3 id="16d5dd5d-2d97-80de-ba33-f0741d898f5c" class="">Vformat()</h3><p id="16d5dd5d-2d97-802f-b4e7-ff17744f2a4b" class="">takes a variable as a format, but this increases flexibility and the chance for run-time errors.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-800c-91f4-c300cb9ab4bc" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">string fmt = &quot;{} {}&quot;;
cout&lt;&lt;vformat(fmt, make_format_args(&quot;arg1&quot;,&quot;arg2&quot;)); // OK: arg1 arg2
fmt = &quot;{:%F}&quot;;
cout&lt;&lt;vformat(fmt, make_format_args(2)); // run-time error: format and arg mismatch
//if format was used, compile time error instead

string buf;
format_to(back_inserter(buf), &quot;iterator: {} {}\n&quot;, &quot;Hi!&quot;, 2022);
cout&lt;&lt;buf; // iterator: Hi! 2022</code></pre><p id="16d5dd5d-2d97-8050-9870-e6ef27deea1c" class="">
</p><h3 id="16d5dd5d-2d97-801b-a188-e5e0d48e507d" class="">Streams</h3><p id="16d5dd5d-2d97-8072-b27a-ff93406bdb13" class=""><strong><span style="border-bottom:0.05em solid">Streams cannot be copied; always pass them by reference.</span></strong></p><p id="16d5dd5d-2d97-8033-8b03-f043045ebc00" class="">All STL streams are templates with character type as parameter.<mark class="highlight-blue"><code><strong> ostream</strong></code></mark> is <mark class="highlight-blue"><code><strong>basic_stream&lt;char&gt;</strong></code></mark>, <mark class="highlight-blue"><code><strong>wostream </strong></code></mark>is <mark class="highlight-blue"><code><strong>basic_stream&lt;wchar_t&gt;</strong></code></mark><mark class="highlight-blue"><strong>. </strong></mark>Wide character streams (wostreams) can be used for unicode.</p><blockquote id="16d5dd5d-2d97-8057-905f-d7a1b0b90c6c" class=""><code>WCHAR</code> (or <code>wchar_t</code> on Visual C++ compiler) is used for <strong>Unicode UTF-16</strong> strings.<br/><br/><code>CHAR</code> (or <code>char</code>) can be used for several other string formats: ANSI, MBCS, UTF-8.</blockquote><p id="16d5dd5d-2d97-80c9-9f0a-eb5f321f1d87" class="">
</p><p id="16d5dd5d-2d97-8063-b680-c936911574ef" class="">Standard streams</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-80b4-9140-caabb7becb36" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">cin // standard input
cout // standard output
cerr // unbuffered error output
clog // buffered logging output</code></pre><p id="16d5dd5d-2d97-8038-b8f8-c217969f4d3c" class="">File streams in <mark class="highlight-blue"><code><strong>&lt;fstream&gt;</strong></code></mark></p><p id="1705dd5d-2d97-80a3-8a5b-cc431a1d6510" class="">A <mark class="highlight-blue"><code><strong>path</strong></code></mark> in C++ is not checked for validity until it is used. Validity depends on the conventions of  the system on which the program runs.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-8011-9ff3-d4f40016a66f" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">ifstream // for reading from a file
ofstream // for writing to a file
fstream // for reading and writing to a file

void use(path p) {
	ofstream f{p};
	if (!f) error(&quot;bad file name: &quot;, p);
	f&lt;&lt;&quot;Hello file!&quot;;
};</code></pre><p id="16d5dd5d-2d97-8050-8c9b-c2a25441aa7a" class="">String Streams in <mark class="highlight-blue"><strong>&lt;sstream&gt;</strong></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="16d5dd5d-2d97-806e-9010-c84d9efdafbf" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">istringstream // for reading from a string
ostringstream // for writing to a string
stringstream // for reading and writing to a string</code></pre><p id="1705dd5d-2d97-8024-8fcc-e4bb4e79a61d" class="">
</p><p id="1705dd5d-2d97-80f9-b6cc-c03aaf26522e" class="">stringstream can be used for both reading and writing. Consider an example function that can convert any type with string representation into another representation that also can be represented as a string.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-804f-9b53-ebcd33145a1a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename Target=string, typename Souce=string&gt;
Target to(Source arg) {
	stringstream buf;
	Target result;
	if (!(buf&lt;&lt;arg) || !(buf&gt;&gt;result) || !(buf&gt;&gt;std::ws).eof() ) 
		throw runtime_error{&quot;to&lt;&gt;() failed&quot;}; // write arg to stream, read result from stream, check stream empty (anything left in stream)
	return result;
};

auto x1 = to&lt;string,double&gt;(1.2); // very explicit and verbose
auto x2 = to&lt;string&gt;(1.2); // source is deduced to double
auto x3 = to(1.2); // &lt;&gt; is redundant, source deduced to double, target defaulted to string</code></pre><p id="1705dd5d-2d97-8068-9e89-ccc64c3120a5" class="">
</p><p id="1705dd5d-2d97-804b-9b31-eaf7a108f352" class="">Memory Streams</p><p id="1705dd5d-2d97-8027-b496-de495f2b95f4" class="">spanstream, ispanstream and ospanstream (will not become official before C++ 23). Spanstreams are similar to stringstreams, except they take <mark class="highlight-blue"><code><strong>spans</strong></code></mark><mark class="highlight-blue"><strong> </strong></mark><mark class="highlight-default"><strong>(i.e std::vector and std::array)</strong></mark><mark class="highlight-blue"><strong> </strong></mark><mark class="highlight-default">rather than string as an argument.</mark></p><p id="1705dd5d-2d97-80a5-a541-d32661135831" class="">
</p><p id="1705dd5d-2d97-805c-86a4-e3c2ca8788da" class="">Note: Attempts to overflow the target buffer sets the stream state to failure.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-807d-9ab9-d25ca6c530d8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void user(int arg) {
	array&lt;char,128&gt; buf;
	ospanstream ss(buf);
	ss&lt;&lt;&quot;write &quot;&lt;&lt;arg&lt;&lt;&quot; to memory\n&quot;;
}</code></pre><p id="1705dd5d-2d97-80f7-b5c8-cab2f6eb2bb4" class="">
</p><h3 id="1705dd5d-2d97-80d6-9727-fb2074473548" class="">Synchronized Streams</h3><p id="1705dd5d-2d97-80a9-b501-ffce29cc978e" class="">In multithreaded system, either one thread uses stream, else ensure access to streams are synchronized - only one thread at a time gains access.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8024-99ea-fb03b78e7ba4" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// different threads may introduce data race
void unsafe(int x, string&amp; s) { cout&lt;&lt;x; cout&lt;&lt;s; }
void safer(int x, string&amp; s) { osyncstream oss(cout); oss&lt;&lt;x; oss&lt;&lt;s; }</code></pre><p id="1705dd5d-2d97-800e-8ee4-f175c2526da1" class="">
</p><h3 id="1705dd5d-2d97-80e8-a7eb-d423e0ad2ee9" class="">C-style I/O</h3><p id="1705dd5d-2d97-8092-8bc2-ece503875448" class="">If you don’t use C-style I/O and care about I/O performance, call</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8007-963f-d8cfd2398f66" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">ios_base::sync_with_stdio(false); // avoid overhead, where cin/cout can be slowed down to be compatiable with C-style I/O</code></pre><h1 id="1705dd5d-2d97-80d5-a336-c01c1dfa312d" class="">Chapter 12: Containers</h1><h3 id="1705dd5d-2d97-80f3-b6c4-c7a10dbfeb47" class="">Vectors</h3><p id="1705dd5d-2d97-8029-adcf-d84f892eab9f" class="">Typical implementation of vector will consist of a handle holding pointers to first element, one-past-the-last-element, and one-past-the-last allocated space. It also holds an allocator (alloc) to acquire and release memory. Default allocator uses <mark class="highlight-blue"><code><strong>new </strong></code></mark>and <mark class="highlight-blue"><code><strong>delete</strong></code></mark> to acquire and release memory.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-80ab-a7cc-c061683cd6b3" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
class Vector {
	allocator&lt;T&gt; alloc;
	T* elem; // pointer to first element
	T* space; // pointer to first unused and uninitialized slot
	T* last; // pointer to last slot
public:
	int size() const { return space-elem; } 
	int capacity() const { return last-elem; }
	
	void reserve(int newsz); // increase capacity() to newsz
	void push_back(const T&amp; t); // copy t into Vector
	void push_back(const T&amp;&amp; t); // move t into Vector
	
}</code></pre><p id="1705dd5d-2d97-804c-ae19-d89d3f2b1285" class="">Note: If you have a class hierarchy that relies on <mark class="highlight-blue"><strong>virtual </strong></mark>functions to get polymorphic behaviour, do not store objects directly in a container. Instead store a pointer/smart pointer.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8047-bc2a-e1c2f416e1f3" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">vector&lt;Shapre&gt; vs; // you cannot store a Circle or Smiley!
vector&lt;Shape*&gt; vps; // better
vector&lt;unique_ptr&lt;Shape&gt;&gt; vups; // OK</code></pre><p id="1705dd5d-2d97-806e-b3b5-cbc96dc175bd" class="">
</p><h3 id="1705dd5d-2d97-805d-9c02-eddfa7ec8a3f" class="">List/Forward List</h3><p id="1705dd5d-2d97-8046-9159-e2a947ef4051" class=""><mark class="highlight-blue"><code><strong>list</strong></code></mark>: doubly-linked list. <mark class="highlight-blue"><code><strong>foward_list</strong></code></mark>: singly linked list</p><ul id="1705dd5d-2d97-80ff-9d8c-e7c79a521e4b" class="bulleted-list"><li style="list-style-type:disc">A list is a sequence, and we can use the for-range loop. </li></ul><ul id="1705dd5d-2d97-808a-8083-c218a6e24762" class="bulleted-list"><li style="list-style-type:disc">To insert/delete element in the list, we can use an <em>iterator.</em></li></ul><blockquote id="1705dd5d-2d97-809a-afad-e28d21567a4d" class="">In general if you have insertions into the data-structure (other than at the end) then <code>vector</code> may be slower, otherwise in most cases <mark class="highlight-yellow_background"><code>vector</code></mark><mark class="highlight-yellow_background"> is expected to perform better than </mark><mark class="highlight-yellow_background"><code>list</code></mark><mark class="highlight-yellow_background"> if only for </mark><mark class="highlight-yellow_background"><a href="http://en.wikipedia.org/wiki/Locality_of_reference">data locality issues</a></mark><mark class="highlight-yellow_background">,</mark> this means that if two elements that are adjacent in the data-set are adjacent in memory then the next element will already be in the processor&#x27;s cache and will not have to page fault the memory into the cache.<br/>Also keep in mind that the space overhead for a <br/><code>vector</code> is constant (3 pointers) while the space overhead for a <code>list</code> is paid for each element, this also reduces the number of full elements (data plus overhead) that can reside in the cache at any one time.</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8091-89ca-f8a8b4762784" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// Note: DLL supports ++p and --p but LL only supports ++p (why? obvious)
// DLL uses erase/insert (before) while LL uses erase_after/insert_after 

void fn()
{
    list&lt;int&gt; lst{1,2,3,4,5};
    lst.insert(lst.begin(), 0); // insert elem BEFORE the pointed elem
    lst.erase(--lst.end()); // remove pointed elem
    for (auto p = lst.begin(); p != lst.end(); p++) { cout&lt;&lt;*p&lt;&lt;&quot; &quot;; }
}
// 0 1 2 3 4

void fn2()
{
    forward_list&lt;int&gt; lst{0,-1,2,3,4};
    lst.insert_after(lst.begin(), 1); // insert elem AFTER the pointed elem
    lst.erase_after(++lst.begin()); // remove single elem AFTER pointed elem 
    for (auto p = lst.begin(); p != lst.end(); p++) { cout&lt;&lt;*p&lt;&lt;&quot; &quot;; }
}
// 0 1 2 3 4</code></pre><p id="1705dd5d-2d97-8003-b719-c25ad06f595f" class="">
</p><h3 id="1705dd5d-2d97-80fa-bfc4-db960fe4254a" class="">Unordered_map</h3><p id="1705dd5d-2d97-80b0-9bd7-fb79c684b41b" class="">There is default hash function for strings as well as other built in STL types. A hash function is often implemented as a functor.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-80f5-bcaa-ebdb03845c57" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">struct Record {
	string name;
	int product_code;
};

struct Rhash { // a hash function for Record
	size_t operator()(const Record&amp; r) const {
		// assuming name or product_code itself is not UID, we can use ^
		return hash&lt;string&gt;()(r.name) ^ hash&lt;int&gt;()(r.product_code); 
	}
};

unordered_set&lt;Record,Rhash&gt; my_set;</code></pre><p id="1705dd5d-2d97-80f6-9a09-de7512c28043" class="">
</p><h3 id="1705dd5d-2d97-8079-8a42-c5ca9a0f5c2c" class="">Allocators</h3><p id="1705dd5d-2d97-80df-ba50-ea7aef281403" class="">Assume a long running system used an event queue using vectors as events. Due to fragmentation, after 100K events had been passed among 16 producers and 4 consumers, more than 6GB memory consumed.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8094-aad7-e6d5bf5159e0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// assuming events are stored as ptrs in q
list&lt;shared_ptr&lt;Event&gt;&gt; q;</code></pre><p id="1705dd5d-2d97-801e-bab5-f60a4810e271" class="">Solution? Use a pool allocator instead. Pool allocator is an allocator that manages objects of <em>a single fixed size </em>and allocates space for <em>many objects at a time, rather than individual</em> allocations. Now, after 100K events has been passed to 16 producers and 4 consumers, less than 3 MB used.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-8047-a6f1-df7701b527fd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">std::pmr::synchronized_pool_resource pool; // make pool
struct Event {
	vector&lt;int&gt; data = vector&lt;int&gt;{512,&amp; pool}; // let Events use pool
}
list&lt;shared_ptr&lt;Event&gt;&gt; q{&amp;pool}; // let q use pool

// sample producer code
void producer() {
	for (int i=0; n!=LOTS; ++n) {
		scoped_lock lk{m}; // m is mutex
		q.push_back(allocate_shared&lt;Event,pmr::polymorphic_allocator&lt;Event&gt;&gt;{&amp;pool});
		cv.notify_one();
	}
}</code></pre><p id="1705dd5d-2d97-8031-9ea2-f9579baf108b" class="">
</p><h3 id="1705dd5d-2d97-8010-8e5a-ed13283e86f5" class="">Container Overview</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1705dd5d-2d97-80f1-9a28-e457b20099f7" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">k=c.capacity() // k is number of elements that c can hold without new allocation

c.reserve(k); // INCREASE capacity to k, if k&lt;=c.capcity(), c.reserve(k) does nothing
c.resize(k); // make number of elements k, added elements have default value value_type{}

v.push_back(pair{1, &quot;copy or move&quot;}); // make a pair and then copy an object into container.
v.emplace_back(1, &quot;build in place&quot;); // NOTE: pass the args only, takes args for an element&#x27;s constructor and builds the object in a newly allocated space in the container.</code></pre><p id="1705dd5d-2d97-8072-8d24-d79866553ede" class="">
</p><h1 id="1705dd5d-2d97-801e-a8d8-ce81da54b72e" class="">Chapter 13: Algorithms</h1><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1725dd5d-2d97-8010-ba6f-c3a7f56d54d2" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">vector&lt;int&gt; vec;
list&lt;int&gt; lst;
copy(vec.begin(), vec.end(), back_inserter(lst)); // append to back of lst</code></pre><p id="1725dd5d-2d97-8082-a38a-c6ac520a8546" class="">The call for<mark class="highlight-blue"><code><strong> back_inserter(lst)</strong></code></mark> constructs an iterator for <mark class="highlight-blue"><code><strong>lst </strong></code></mark>that adds elements to the end of the container, and using STL eliminates explicit call to <mark class="highlight-blue"><code><strong>realloc</strong></code></mark>.</p><p id="1725dd5d-2d97-80db-a648-efeff7cd2b21" class="">
</p><h3 id="1725dd5d-2d97-80bd-b4bf-e2e67e5f7a55" class="">Iterators</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1725dd5d-2d97-80ef-9525-de08edb840d2" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">bool has_c(const string&amp; s, char c) {
	auto p = find(s.begin(), s.end(), c); // use find
	return p!=s.end();
}

template&lt;typename C, typename V&gt;
vector&lt;typename C::iterator&gt; find_all(C&amp; c, V v) {
	vector&lt;typename C::iterator&gt; res; // to refer to a type member of a template parameter, use ‘typename C::iterator’
	for (auto p = c.begin(); p!=c.end(); ++p) {
		if (*p==v)
			res.push_back(p);
	}
	return res;
}

void test()
{
    string m{&quot;Mary had a little lamb&quot;};
    for (auto p : find_all(m, &#x27;a&#x27;)) {
        if (*p != &#x27;a&#x27;) 
            cerr&lt;&lt;&quot;a bug!\n&quot;;
    }
}</code></pre><p id="1725dd5d-2d97-80e0-880a-ef95b8ecaffb" class=""><mark class="highlight-blue"><code><strong>typename </strong></code></mark>in <mark class="highlight-blue"><code><strong>typename C::iterator</strong></code></mark> needed to inform compiler that C’s iterator is supposed to be a type and not a value of some type.</p><p id="1725dd5d-2d97-801f-9672-ebc15199ee16" class="">Iterators are used to separate algorithms and containers. An algorithms operates on its data through iterators and knows nothing about the container. <strong>A container knows nothing about the iterator algorithms operating on its elements</strong> - it supply iterators upon request.</p><figure id="1775dd5d-2d97-8038-93a1-df2938d1f680" class="image"><a href="image%201.png"><img style="width:593px" src="image%201.png"/></a></figure><ul id="1775dd5d-2d97-8009-ba0b-c6cdcd6efad5" class="bulleted-list"><li style="list-style-type:disc">For various STL algorithms like <strong><a href="https://www.geeksforgeeks.org/stdnth_element-in-cpp/">std::nth_element</a></strong>, <strong><a href="https://www.geeksforgeeks.org/sort-c-stl/">std::sort</a></strong>, you must have found their template definition consisting of objects of type <strong>Random-access Iterator</strong>. </li></ul><ul id="1775dd5d-2d97-8057-883f-dac5e94c76ae" class="bulleted-list"><li style="list-style-type:disc">For various STL algorithms like <strong><a href="https://www.geeksforgeeks.org/stdreverse-in-c/">std::reverse</a></strong>, <strong><a href="http://www.cplusplus.com/reference/algorithm/next_permutation/">std::next_permutation </a></strong>and <strong><a href="http://www.cplusplus.com/reference/algorithm/reverse_copy/">std::reverse_copy</a></strong> you must have found their template definition consisting of objects of type <strong>Bidirectional Iterator</strong>.</li></ul><ul id="1775dd5d-2d97-801c-89b1-e7c4a192e20b" class="bulleted-list"><li style="list-style-type:disc">For various STL algorithms like <strong><a href="https://www.geeksforgeeks.org/stdsearch-in-c/">std::search</a></strong>, <strong><a href="https://www.geeksforgeeks.org/stdsearch_n-with-example-in-cpp/">std::search_n</a></strong>, <strong><a href="https://www.geeksforgeeks.org/stdlower_bound-in-c/">std::lower_bound</a></strong>, you must have found their template definition consisting of objects of type <strong>Forward Iterator</strong>.</li></ul><ul id="1775dd5d-2d97-804f-aab6-ffaca35bd242" class="bulleted-list"><li style="list-style-type:disc">For various STL algorithms like <strong><a href="https://www.geeksforgeeks.org/different-methods-copy-c-stl-stdcopy-copy_n-copy_if-copy_backwards/">std::copy</a></strong>, <strong><a href="https://www.geeksforgeeks.org/stdmove-in-c/">std::move</a></strong>, <strong><a href="https://www.geeksforgeeks.org/transform-c-stl-perform-operation-elements/">std::transform</a></strong>, you must have found their template definition consisting of objects of type <strong>Output Iterator</strong>. Output Iterators can be <mark class="highlight-yellow_background"><strong>assigned values in a sequence</strong></mark>, but cannot be used to access values (opposite of Input Iterators)</li></ul><ul id="1775dd5d-2d97-800c-8c21-f0e15e011301" class="bulleted-list"><li style="list-style-type:disc">For various STL algorithms like <strong><a href="https://www.geeksforgeeks.org/stdfind-in-c/">std::find</a></strong>, <strong><a href="https://www.geeksforgeeks.org/stdequal-in-cpp/">std::equal</a></strong>, <strong><a href="https://www.geeksforgeeks.org/std-count-cpp-stl/">std::count</a></strong>, you must have found their template definition consisting of objects of type <strong>Input Iterator</strong>. They be used in sequential input operations, where each value pointed by the <mark class="highlight-yellow_background">iterator is read-only once</mark> and then the iterator is incremented.</li></ul><p id="1725dd5d-2d97-8001-aa16-ce98074427c9" class="">
</p><p id="1725dd5d-2d97-8083-9b17-ed5687a0e4d1" class=""><strong>What are iterators really?</strong> For example, in vectors, iterator can be pointers, or pointers with position index. Meanwhile, a list iterator must be more complicated because a list does not know where the next element of the list is. Thus, a list iterator might be a pointer to a link (link node).</p><p id="1775dd5d-2d97-803d-82c9-d737a31ac4a3" class="">
</p><p id="1775dd5d-2d97-80a3-9aa2-f6fca4d9f84e" class="">Containers knows its iterator types (types are determined based on the template arguments provided when the container is instantiated, and compiler resolves it during <strong>compilation process</strong>) and makes them available under the conventional names of <mark class="highlight-blue"><code><strong>iterator </strong></code></mark>and <mark class="highlight-blue"><code><strong>const_iterator</strong></code></mark><mark class="highlight-blue"><strong>.</strong></mark></p><p id="1775dd5d-2d97-8081-be5d-e5ece55c7441" class="">
</p><h3 id="1725dd5d-2d97-80b6-a42b-d80653400e3b" class="">Stream Iterators</h3><p id="1775dd5d-2d97-80d8-b4d7-e287971446c6" class="">Containers are not the only place where we find sequence of elements. The notion of iterators can be usefully applied to input/output.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1775dd5d-2d97-805e-98c3-fcc960778ff7" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void fn1() {
    ostream_iterator&lt;string&gt; oo{cout}; // write strings to cout
    vector&lt;string&gt; vec{&quot;Hello, &quot;, &quot;world!\n&quot;}; 
    copy(vec.begin(), vec.end(), oo);
}

void fn2() {
    ostream_iterator&lt;string&gt; oo{cout};
    *oo = &quot;Hello, &quot;;
    ++oo;
    *oo = &quot;world!\n&quot;;
}</code></pre><p id="1775dd5d-2d97-8059-bc20-e1091a7477b3" class="">
</p><h3 id="1775dd5d-2d97-8071-b03e-cb5e4881ccf1" class="">Predicates</h3><p id="1775dd5d-2d97-80a0-bcaa-ce6613847b60" class="">The <mark class="highlight-blue"><code>find</code></mark> algorithm provides a way of looking for a specific value. A more general variant looks for a predicate. We can pass a functor (function object) to be compared using <mark class="highlight-blue"><code><strong>find_if</strong></code></mark>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1775dd5d-2d97-801a-8fc2-c7db8bfeaf13" class="code"><code class="language-C++">map&lt;string, int&gt; m;
auto p = find_if(m, [](const auto&amp; r) { return r.second &gt; 42; });

struct Greater_than {
	int val;
	Greater_than(int v) : val{v} {}
	bool operator()(const pair&lt;string,int&gt;&amp; r) { return r.second&gt;val; }
};
auto p = find_if(m, Greater_than{42});</code></pre><p id="1775dd5d-2d97-8093-a8fb-de8a5e4cdf5b" class="">
</p><h3 id="1775dd5d-2d97-80ee-a2ac-d5575fadc3fa" class="">Parallel Algorithms</h3><p id="1775dd5d-2d97-8037-979c-f47d6a4583a6" class="">Parallel Execution: tasks are done on multiple threads (often running on several processor cores)</p><p id="1775dd5d-2d97-80c5-9b87-dcb1f588c00e" class="">Vectorized Execution: tasks are done on single thread using vectorization, aka SIMD (Single Instruction, Multiple Data)</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1775dd5d-2d97-8090-b159-ed4a70f9728d" class="code"><code class="language-C++">// Only from C++ 17 onwards, works on find/find_if, sort, count/count_if
#include &lt;execution&gt;
sort(execution::seq, v.begin(), v.end()); // sequential, same as default
sort(execution::par, v.begin(), v.end()); // parallel
sort(execution::unseq, v.begin(), v.end()); // vectorized
sort(execution::par_unseq, v.begin(), v.end()); // parallel and/or vectorized</code></pre><p id="1775dd5d-2d97-80d1-a41b-f7ae1523543c" class="">However, these execution policies indicators are just hints. Compiler and/or run-time scheduler will decide how much concurrency to use. Many parallel algorithms are primarily for numeric data. Note: in parallel execution - you must be sure to avoid data races and deadlocks.</p><p id="1775dd5d-2d97-8054-9a2a-cb6721185715" class="">
</p><h1 id="1775dd5d-2d97-80b0-a49a-ccdb46a325b4" class="">Chapter 14: Ranges</h1><p id="1775dd5d-2d97-8083-9831-da10ad3bd4fc" class="">C++ 20. The range library includes set of standard algorithms that support activities like data filtering, transformation, and sorting on constrained types (using concepts) are in the &lt;ranges&gt; in namespace ranges. </p><p id="1775dd5d-2d97-8068-97a3-c4ec81cdc200" class="">
</p><p id="1775dd5d-2d97-80b4-963b-f47d5594d693" class="">There are different ranges (concepts) corresponding to the different kinds of iterators, like <mark class="highlight-blue"><code><strong>input_range</strong></code></mark>, <mark class="highlight-blue"><code><strong>forward_range</strong></code></mark>, <mark class="highlight-blue"><code><strong>bidirectional_range</strong></code></mark> (consider: <mark class="highlight-blue"><code><strong>list</strong></code></mark> vs <mark class="highlight-blue"><code><strong>forward_list</strong></code></mark>), <mark class="highlight-blue"><code><strong>random_access_range</strong></code></mark> (consider: vector/deque vs map/set), <mark class="highlight-blue"><code><strong>contiguous_range</strong></code></mark></p><p id="1775dd5d-2d97-8085-a82d-fd42f9b5a51f" class="">
</p><p id="1775dd5d-2d97-8028-9421-c4805f437211" class="">The ranges library includes <mark class="highlight-blue"><strong><a href="https://en.cppreference.com/w/cpp/algorithm/ranges">range algorithms</a></strong></mark><mark class="highlight-blue"><strong>,</strong></mark> which are applied to ranges <span style="border-bottom:0.05em solid">eagerly</span>, and<mark class="highlight-blue"><strong> </strong></mark><mark class="highlight-blue"><strong><a href="https://en.cppreference.com/w/cpp/ranges#Range_adaptors">range adaptors</a></strong></mark>, which are applied to views <span style="border-bottom:0.05em solid">lazily</span>. </p><p id="1775dd5d-2d97-8090-954e-ee20e9a64247" class="">
</p><h3 id="1775dd5d-2d97-80ae-b3c0-c377c1f9d567" class="">Views</h3><p id="1775dd5d-2d97-80a3-ad24-f060d41b0042" class="">Views is a way of looking at a range. Views are also known as <em>range adaptors</em>. </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-80cb-a1cb-fb4aa9e37970" class="code"><code class="language-C++">#include &lt;ranges&gt;

void user(forward_range auto&amp; r) {
	for (int x : ranges::take_view{ranges::filter_view{r, [](int x) { return x%2;} }, 3})
		cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;
}

// STL Views. v is a view, r is range, p is predicate, n in integer
v=filter_view{r,p}
v=transform_view{r,f}
v=take_view{r,n} // v is at most n elements from r
v=drop_view{r,n} // v is elements from r starting with the n+1th element</code></pre><p id="1775dd5d-2d97-80f1-83f3-e4e192886a74" class="">Note: Actually, a view offers an ‘interface’ that is very similar to that of a range, so in most cases we can use a view whenever we can use a range in the same way. The key difference is - <mark class="highlight-yellow_background">view doesn’t own its elements, it is not responsible for deleting the elements of its underlying range - that’s the ranges responsibility. </mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-8055-a733-df9774f77ec1" class="code"><code class="language-C++">auto bad() {
	vector v = {1,2,3,4};
	return filter_view{v,odd}; // error: v will be destroyed before the view
}</code></pre><p id="1795dd5d-2d97-80f2-b65a-da45382e3bfb" class="">
</p><h3 id="1795dd5d-2d97-80e6-ae81-c9d2774c284e" class="">Generators</h3><p id="1795dd5d-2d97-807e-8265-c4d1bc457574" class="">Generators are <em>factories</em>, useful for generating ranges on a fly. Some range factories below:</p><table id="1795dd5d-2d97-805a-bef5-f677e77dc26c" class="simple-table"><tbody><tr id="e8b52392-e1ab-45aa-b07d-a55d242f10be"><td id="jkrt" class="" style="width:237px">v=empty_view&lt;T&gt;{}</td><td id="bKEI" class="" style="width:486px">v is empty range of type T elements</td></tr><tr id="b5663226-2872-4731-8844-7c5ffde01c64"><td id="jkrt" class="" style="width:237px">v=single_view{x}</td><td id="bKEI" class="" style="width:486px">v is the range of one element x</td></tr><tr id="405a84d8-ee87-4782-ae64-6f2d92a09ff1"><td id="jkrt" class="" style="width:237px">v=iota_view{x}</td><td id="bKEI" class="" style="width:486px">v is infinite range of elements, x, x+1, x+2, x+3, … (incrementing using ++)</td></tr><tr id="1795dd5d-2d97-8070-810f-c4e214feaa12"><td id="jkrt" class="" style="width:237px">v=iota_view{x,y}</td><td id="bKEI" class="" style="width:486px">v is finite of elements from x … to y-1. (incrementing using ++)</td></tr><tr id="1795dd5d-2d97-80a9-b56d-c24c05214d26"><td id="jkrt" class="" style="width:237px">v=istream_view&lt;T&gt;{is}</td><td id="bKEI" class="" style="width:486px">v is range obtained by calling &gt;&gt; for T on is</td></tr></tbody></table><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-8048-8efe-d2d092d802e9" class="code"><code class="language-C++">for (int x : ranges::iota_view(2,5)) {
	cout&lt;&lt; x &lt;&lt; &#x27; &#x27;;
}

auto cplx = ranges::istream_view&lt;complex&lt;double&gt;&gt;(cin);
for (auto x : ranges::transform_view(cplx, [](auto z){ return z*z; })) {
	cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;
}</code></pre><p id="1795dd5d-2d97-80a5-897a-e96f381a2224" class="">
</p><h3 id="1795dd5d-2d97-8072-90ec-fc30eeb3ee10" class="">Pipelines</h3><p id="1795dd5d-2d97-80ee-b445-c7239d034119" class="">Initial r has to be a range or a generator.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-80a6-918b-d754d202f50e" class="code"><code class="language-C++">auto user(ranges::forward_range auto&amp; r) {
    auto odd = [](int x){ return x%2; };
    for (int x : r | views::filter(odd) | views::take(3)) {
        cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;
    }
    return r | views::filter(odd) | views::take(3);
}

vector&lt;int&gt; r = {1,2,3,4};
ranges::take_view tv = user(r);
for (int x : tv) {
    cout&lt;&lt; x &lt;&lt; &#x27; &#x27;;
}</code></pre><p id="1795dd5d-2d97-80fa-8565-d095ff1afed1" class="">
</p><h3 id="1795dd5d-2d97-80b4-a0b9-db17cb5a5cd6" class="">Concepts Overview</h3><p id="1795dd5d-2d97-808e-ba3f-f76988cf7745" class=""><strong>1.1 Types Concepts: Concepts defining properties of types and the relations among types</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-806e-a442-d43a4fdb6987" class="code"><code class="language-C++">same_as&lt;T,U&gt; // T is same as U
derived_from&lt;T,U&gt; // T is derived from U
convertible_to&lt;T,U&gt; // T can be converted to U

// to specify a common pair of types
using common_type_t&lt;Bigint, long&gt; = Bigint; // suitable definition for Bigint</code></pre><p id="1795dd5d-2d97-80a9-90ca-e1739f92cc45" class=""><strong>1.2 Comparison Concepts</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-808e-b977-dcf6c33c63a8" class="code"><code class="language-C++">equality_comparable_with&lt;T,U&gt; // T and U can be compared using ==
equality_comparable&lt;T&gt; // T and T can be compared using ==
totally_ordered_with&lt;T,U&gt; // T and U yield total order, &lt; &lt;= == &gt;= &gt;
totally_ordered&lt;T&gt; // strict total ordering T and T</code></pre><p id="1795dd5d-2d97-8008-b5cb-c62d13f80f6f" class=""><strong>1.3 Object concepts</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-80e7-b7c3-c6017a1b0f10" class="code"><code class="language-C++">destructible&lt;T&gt;, constructible_from&lt;T,Args&gt;, default_initializable&lt;T&gt;
move_constructible&lt;T&gt; // A T can be move constructed
copy_constructible&lt;T&gt; // A T can be copy constructed and move constructed
movable&lt;T&gt; // move constructable&lt;T&gt;, assignable&lt;T&amp;, T&gt;, and swapable&lt;T&gt;
copyable&lt;T&gt; // copy constructable, movable&lt;T&gt; and assignable&lt;T, const T&amp;&gt;
semiregular&lt;T&gt; // copyable&lt;T&gt; and default constructable&lt;T&gt;
regular&lt;T&gt; // semiregular&lt;T&gt; and equality_comprable&lt;T&gt;</code></pre><p id="1795dd5d-2d97-8086-8e75-cef11ddae4df" class=""><strong>1.4 Callable concepts</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-8041-9b95-d9cdceb04c18" class="code"><code class="language-C++">invocable&lt;F,Args&gt; // An F can be invoked with argument list of type Args
regular_invocable&lt;F,Args&gt; // invocable&lt;F,Args&gt; and is equality preserving</code></pre><p id="1795dd5d-2d97-804d-aeaf-c3c4b97f9c2d" class="">Equality preserving that means x==y implies f(x) == f(y).</p><p id="1795dd5d-2d97-809b-b2a3-c683d0d4c89f" class="">Callable concepts also include relation, equivalence relation (reflexive aRa, symmetric aRb → bRa, and transitive aRb and bRc → aRc), and strict weak order (i.e &lt;, not compare apples and oranges)</p><p id="1795dd5d-2d97-80fd-8175-ce25e5ceaab0" class="">
</p><p id="1795dd5d-2d97-809e-8abb-d693c70da59f" class=""><strong>2.1 Iterator concepts - Since STL algorithms access containers/data through iterators, we need concepts to classify properties of iterator types.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-80f8-bf35-cc049aa441d8" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">input_iterator&lt;I&gt;, output_terator&lt;I&gt;, forward_iterator&lt;I&gt;, bidirectional_iterator&lt;I&gt;, random_access_iterator&lt;T&gt;, contiguous_iterator&lt;I&gt; // (random access for elements in contiguous memory)
permutable&lt;I&gt; // forward iterator supporting move and swap
mergable&lt;I1,I2,R,O&gt; // merge sorted sequences of I1 and I2 into O using relation&lt;R&gt;
sortable&lt;I&gt; // sort I sequences using less
sortable&lt;I,R&gt; // sort I sequences using relation&lt;R&gt; </code></pre><p id="1795dd5d-2d97-80ed-a68e-edce25d3e9d8" class=""><strong>2.2 Range concepts - define properties of ranges</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-80a0-9301-df4e271cbe34" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">// input_range&lt;R&gt;, output_range&lt;R&gt;, forward_range&lt;R&gt;, bidrectional_range&lt;R&gt;, random_access_range&lt;R&gt;, contiguous_range&lt;R&gt;

range&lt;R&gt; // range with begin iterator and sentinel
sized_range&lt;R&gt; // range that knows its size in constant time
view&lt;R&gt; // range with constant time copy, move, assignment

// common_range&lt;R&gt;
#include &lt;ranges&gt;
struct A
{
    char* begin();
    char* end();
};
static_assert( std::ranges::common_range&lt;A&gt; );
 
struct B
{
    char* begin();
    bool end();
};  // not a common_range: begin/end have different types
static_assert( not std::ranges::common_range&lt;B&gt; );
 
struct C
{
    char* begin();
};  // not a common_range, not even a range: has no end()
static_assert( not std::ranges::common_range&lt;C&gt; );
 
int main() {}</code></pre><p id="1795dd5d-2d97-804b-b24d-cdb73ffe120b" class="">
</p><h1 id="1795dd5d-2d97-8032-95ff-ef87c07bf7af" class="">Chapter 15: Pointers and Containers </h1><h3 id="1795dd5d-2d97-80cf-9060-f3dbd27244e6" class="">Pointers</h3><p id="1795dd5d-2d97-8082-ba2d-ff0ff8d6c083" class="">Owning pointers is one that is responsible for eventually deleting the object it refers to.</p><p id="1795dd5d-2d97-80dd-b116-f369e1b5d538" class=""><em>Non-owning </em>pointer (<mark class="highlight-blue"><code>T*</code></mark> or a <mark class="highlight-blue"><code><strong>span</strong></code></mark><mark class="highlight-blue"><strong> </strong></mark><mark class="highlight-default">or a </mark><mark class="highlight-blue"><code><strong>string_view</strong></code></mark>) can <em>dangle</em>, that is, point to a location where an object has been <mark class="highlight-blue"><code><strong>deleted </strong></code></mark>or gone out of scope.</p><p id="1795dd5d-2d97-8095-98e0-f54fc60d9156" class=""><mark class="highlight-yellow_background">Reading or writing through a dangling pointer, the result of doing so is </mark><mark class="highlight-yellow_background"><strong>technically undefined </strong></mark><mark class="highlight-yellow_background">(aka the best we hope for is a crash, because that is preferable to a wrong result). Read means getting arbitrary value, write scrambles unrelated data structure.</mark></p><ul id="1795dd5d-2d97-8043-a141-e86bcffd00c1" class="bulleted-list"><li style="list-style-type:disc">Don’t retain a pointer to local object after object goes out of scope. </li></ul><ul id="1795dd5d-2d97-804d-a924-e531bdb6196f" class="bulleted-list"><li style="list-style-type:disc">Use owning pointers to objects allocated on the free store</li></ul><ul id="1795dd5d-2d97-80ce-add5-e34d1649a161" class="bulleted-list"><li style="list-style-type:disc">Pointers to static objects (i.e global variables) can’t dangle</li></ul><ul id="1795dd5d-2d97-800d-aae5-e520b9942e9b" class="bulleted-list"><li style="list-style-type:disc">Leave pointer arithmetic to implementation or resource handles (such as <mark class="highlight-blue"><code><strong>vectors</strong></code></mark> and <mark class="highlight-blue"><code><strong>unordered_map</strong></code></mark>)</li></ul><p id="1795dd5d-2d97-8091-b08c-d06710383b44" class="">
</p><p id="1795dd5d-2d97-807c-b4f1-f08d4f5a3a79" class="">The use of a constructor/destructor pair in Vector to manage lifetime of its elements is an example and all STL containers are implemented in similar ways. For example, in lock classes:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-8051-b685-c642ead6ee11" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">mutex m; // used to protect access to shared data

void f() {
	scoped_lock lck{m}; // acquire the mutex m
	// ... manipulate the shared data ...
}</code></pre><p id="1795dd5d-2d97-80b8-a635-fce9216764ac" class="">A thread will not proceed until <mark class="highlight-blue"><code><strong>lck’</strong></code></mark>s constructor has acquired the mutex. The corresponding destructor releases the mutex - <mark class="highlight-blue"><code><strong>scoped_lock</strong></code></mark>’s destructor releases the mutex when the thread of control leaves <mark class="highlight-blue"><code><strong>f()</strong></code></mark> (through <mark class="highlight-blue"><code><strong>return</strong></code></mark>,  by falling off the end of the function, or through an exception throw). This is an application of RAII.</p><p id="1795dd5d-2d97-8027-b88a-d5860937822c" class="">
</p><h3 id="1795dd5d-2d97-80c0-9744-e4121198795c" class="">unique_ptr and shared_ptr</h3><p id="1795dd5d-2d97-800b-a592-f45508e8fe84" class="">What about objects allocated on the free store? We have smart pointers to help manage:</p><ul id="1795dd5d-2d97-805c-86e9-d2ee03336fa9" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>unique_ptr</strong></code></mark>: represents unique ownership (its destructor destroys its object)</li></ul><ul id="1795dd5d-2d97-8054-8ea9-fbec055ab2fb" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>shared_ptr</strong></code></mark>: represents shared ownership (the last shared pointer’s destructor destroys the object).</li></ul><p id="1795dd5d-2d97-8028-b047-d4e777b662be" class="">
</p><blockquote id="1795dd5d-2d97-80e5-9cc5-c47f36673888" class="">The <code>std::shared_ptr</code> uses automatic reference counting to track the number of <code>std::shared_ptr</code> instances pointing to the object. The reference count increments and decrements are thread-safe because the it is implemented using atomic operations. However, <mark class="highlight-yellow_background"><strong>accessing the object itself is not thread-safe</strong></mark> if the object itself is not thread-safe. It’s the user’s responsibility to ensure the object access is thread-safe and mutual exclusion locks are often used.</blockquote><p id="1795dd5d-2d97-80f6-be92-f69bea7dc8e6" class="">
</p><p id="1795dd5d-2d97-804a-86f8-c2de80859a59" class="">When do we need pointer semantics?</p><ul id="1795dd5d-2d97-80b5-ad45-da5147a26de3" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue">When we share an object</mark>, we need pointers (or references) to refer to shared object, so can use <mark class="highlight-blue"><code><strong>shared_ptr</strong></code></mark></li></ul><ul id="1795dd5d-2d97-8082-8abb-efbc7ba2ad14" class="bulleted-list"><li style="list-style-type:disc">When we <mark class="highlight-blue">refer to polymorphic object</mark> in OOP code, we need pointer (or reference) because we don’t know the exact type (or even size) of object, so can use <mark class="highlight-blue"><code><strong>unique_ptr</strong></code></mark></li></ul><ul id="1795dd5d-2d97-80f7-a2a5-d574448134ba" class="bulleted-list"><li style="list-style-type:disc">A shared polymorphic object typically requires <mark class="highlight-blue"><code><strong>shared_ptr</strong></code></mark></li></ul><p id="1795dd5d-2d97-8041-8b41-f0c19845ab64" class="">
</p><p id="1795dd5d-2d97-808b-b836-c13d9f7f49b3" class="">When do we not need to use pointers? When returning a collection of objects from a function, container is a resource handle that will use copy elision and move semantics.</p><p id="1795dd5d-2d97-809c-8106-e0f86344e65e" class="">
</p><h3 id="1795dd5d-2d97-8015-9141-eeac2e068695" class="">Polymorphism and Object Slicing</h3><p id="1795dd5d-2d97-8063-8461-ce8c6d2f2c01" class=""><strong>object slicing: w</strong>hen a derived class object is assigned to a base class object, the derived class object’s extra attributes are sliced off (not considered) to generate the base class object, so polymorphism doesn’t work.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-804f-b2c8-df8e05fc6939" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Base c = Derived(); // c object is a Base, not Derived</code></pre><p id="1795dd5d-2d97-8008-ba0c-e3c5171ebe4e" class="">
</p><p id="1795dd5d-2d97-804b-97b7-fb6d5a3252fe" class="">Now take</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1795dd5d-2d97-8016-bae7-d0546acf472c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Base* c = new Derived();</code></pre><p id="1795dd5d-2d97-80a3-8ed8-cb306e42854e" class="">We can avoid the unexpected behavior use the use of pointers or references. <code>c</code> just points to some place in memory (since pointers/references of any type takes the same amount of memory), and you don&#x27;t really care whether that&#x27;s actually a <code>Base</code> or a <code>Derived</code>, but the call to a <code>virtual</code> method will be resolved dynamically.</p><p id="17a5dd5d-2d97-80d7-8728-fc4533925ad9" class="">
</p><h3 id="1795dd5d-2d97-802a-82a4-ff28aad2a004" class="">std::array </h3><p id="17a5dd5d-2d97-8027-9b5b-e58d90686a32" class="">Array vs vector. std::array has<mark class="highlight-yellow_background"> performance advantage by directly accessing elements allocated on stack</mark> rather than allocating elements on free store and accessing them indirectly through the vector (a handle). </p><p id="17a5dd5d-2d97-8038-b6aa-cc415e0a6e06" class="">But stack is a limited resource (especially on some embedded systems), and may cause stack overflow. OS imposes strict size limit else if the stack would be allowed to grow arbitrarily large, errors like infinite recursion would be caught very late, when OS resources are exhausted.</p><p id="17a5dd5d-2d97-8083-bbd5-c11dd972b4fb" class="">Generally, stack’s LIFO structure keeps track of call stack and local variables. Because of LIFO structure, moving objects around becomes inefficient. Also if you create many threads, they will need one stack each. If all stacks are allocating multi-MBs, but not using it, space will be wasted. </p><p id="17a5dd5d-2d97-80af-b2b8-d0dab48b06a7" class="">
</p><p id="17a5dd5d-2d97-8026-9c0e-d8b53d3a949b" class="">std::array vs built in array. std::array knows it size, and it can be copied with =.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-80d1-94e8-f68444af6f38" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">array&lt;int&gt; a1 = {1,2,3};
auto a2 = a1; // copy
a2[1] = 5;
a1 = a2; // assign</code></pre><p id="17a5dd5d-2d97-803f-a378-d27e933f37f4" class="">Another benefit - saves user from surprising conversions. Example: class hierarchy.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-80b9-9302-d20e8e1aa9a2" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">Circle a1[10];
array&lt;Circle,10&gt; a2;
Shape* p1 = a1; // OK: disaster waiting to happen
Shape* p2 = a2; // error: no conversion of array&lt;Circle,10&gt; to Shape*
p1[3].draw(); // disaster - if sizeof(Shape) &lt; sizeof(Circle), subscripting a Circle[] through Shape* gives wrong offset.</code></pre><p id="17a5dd5d-2d97-80b1-8bf9-fe892fb08f32" class="">
</p><h3 id="17a5dd5d-2d97-8085-9db4-db8d2c7d302e" class="">std::bitset</h3><p id="17a5dd5d-2d97-8083-9ef6-d540f41aef07" class="">For bits that don’t fit into a long long int (often 64 bits), using a bitset is more convenient.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-80bc-9365-e02aaaeb0e63" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;bitset&gt;
int i = 5;
bitset&lt;9&gt; bs1 {&quot;10001111&quot;}; // reads the first 9 bits
bitset&lt;9&gt; bs2 {0b1&#x27;1000&#x27;1111}; // binary literal using digit separator &#x27; for readability
bitset&lt;8*sizeof(int)&gt; bs3 = i; // initalize with int

// some common functions
bs1.all(); // false - not all bits set
bs1.none(); // none of bits set?
bs1.any(); // any bits set?
bs1.test(0); // idx 0 value - 0 from LSD/RHS
bs1.count() // count number of set bits
bs1.flip(0); // flip bit at idx 0</code></pre><p id="17a5dd5d-2d97-8049-9fa3-e7c200fa3852" class="">
</p><h3 id="17a5dd5d-2d97-80fe-9070-ca244550722a" class="">Union and std::variant</h3><p id="17a5dd5d-2d97-806e-89a0-fd9864e91055" class="">A union is a struct in which all members are allocated same address, so that union occupies only as much space as its largest member. Union can only hold a value for one member at a time. But union doesn’t keep track of which kind of value it holds!</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-806c-9f1c-d67c63b565e7" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">union Value {
	Node* p;
	int i;
}

struct Entry {
	string name;
	Type t; // custom type to identify if Value is Node pointer or int
	Value v;
}</code></pre><p id="17a5dd5d-2d97-808e-8e7a-e3bdfeb30246" class=""><mark class="highlight-blue"><code><strong>variant&lt;A,B,C&gt;</strong></code></mark> is a safer alternative to union. If we try to access variant holding a different type from expected, <mark class="highlight-blue"><code><strong>bad_variant_access</strong></code></mark> is thrown.</p><p id="17c5dd5d-2d97-8077-8ce7-f797156b56c1" class="">
</p><p id="17a5dd5d-2d97-8035-b79a-fa53e03a3044" class="">std::visit and Overloaded</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-80a0-8014-cff28639dccd" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">using Node = variant&lt;Expression, Statement, Declaration, Type&gt;;

// if else check relatively inefficent
void check(Node* p) {
	if (holds_alternative&lt;Expression&gt;(*p)) {
		Expression&amp; e = get&lt;Expression&gt;(*p);
		// ...
	} else if (holds_alternative&lt;Statement&gt;(*p)) {
		Statement&amp; s = get&lt;Statement&gt;(*p);
		// ...
	}
}


void check(Node* p) {
	std::visit(overloaded {
	[](Expression &amp;e) { ... },
	[](Statement &amp;s) { ... },
		// ...
	}, *p);
}
// using std::visit and overloaded class </code></pre><h3 id="17a5dd5d-2d97-8083-8b23-e9c73c0c9516" class="">std::optional</h3><p id="17a5dd5d-2d97-809e-9020-c301390b70ff" class="">If we try to access an optional that does not hold value, the result is undefined and exception is NOT thrown.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-80d1-96d5-f199104f1bfa" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">optional&lt;int&gt; sum(optional&lt;int&gt; a, optional&lt;int&gt; b) {
    return *a+*b; // accessing optional that does not hold value via * (ptr to object)
}

void fn()
{
    optional&lt;int&gt; s = sum({}, {});
    cout &lt;&lt; s.value_or(-1); // cout a random number instead of -1
}</code></pre><p id="17a5dd5d-2d97-8054-8d9d-f129360bda30" class="">
</p><h3 id="17a5dd5d-2d97-80a6-a51d-e66f447eeaab" class="">std::any</h3><p id="17a5dd5d-2d97-804d-8e43-c79dd72b3b8c" class="">If we try to access an any holding different type from expected one, <mark class="highlight-blue"><code><strong>bad_any_access</strong></code></mark> is thrown.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17a5dd5d-2d97-802e-85a6-dda3d60d8f6e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">any compose(isstream&amp; s) { ... }
auto m = compose(cin);
string &amp; s = any_cast&lt;string&gt;(m);
cout&lt;&lt;s;</code></pre><p id="17a5dd5d-2d97-80d0-ac7a-f63366aa02bb" class="">
</p><h1 id="17a5dd5d-2d97-800b-b8cb-f6e4e7aa9481" class="">Chapter 16: Utilities</h1><h3 id="17a5dd5d-2d97-8029-98b1-d8e0f9635771" class="">Function Adaptation</h3><p id="17c5dd5d-2d97-80d0-88a4-e8e4dcd6e7cd" class="">When passing a function as a function argument, we can consider:</p><ul id="17c5dd5d-2d97-8040-b901-c434f3df170b" class="bulleted-list"><li style="list-style-type:disc">Use a lambda</li></ul><ul id="17c5dd5d-2d97-8036-9fcf-ebb186e13025" class="bulleted-list"><li style="list-style-type:disc">Use <mark class="highlight-blue"><code><strong>std::mem_fn()</strong></code></mark> to make function object from a member function</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-8070-b1c4-e79f51670e65" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void draw_all(vector&lt;Shape*&gt;&amp; v) {
	for_each(v.begin(), v.end(), mem_fn(&amp;Shape::draw));
}
// auto f = mem_fn(&amp;Shape::draw)); where f is a functor equivalent to f = [](Shape* p){ p-&gt;draw(); };</code></pre><ul id="17c5dd5d-2d97-8065-9db7-da8115711ec3" class="bulleted-list"><li style="list-style-type:disc">Define the function to accept std::function. An object of type <mark class="highlight-blue"><code><strong>function </strong></code></mark>is a <em>function object</em>. <mark class="highlight-blue"><code><strong>function</strong></code></mark> , being an object, does not participate in overloading </li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-805c-8da9-e431db6b7723" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int f1(double);
function&lt;int(double)&gt; fct1{f1}; // initialize to f1
int f2(string);
function fct2{f2}; // fct2&#x27;s type is deduced from initializer f2, so type is function&lt;int(string)&gt;</code></pre><p id="17c5dd5d-2d97-8079-891c-c8185d78d327" class="">For a function object which the size is not computed at compile time, free store allocation might occur, which has bad implications to performance critical applications. For C++ 23 solution: move_only_function</p><p id="17c5dd5d-2d97-8018-8e23-d08bfd4918f3" class="">
</p><h3 id="17c5dd5d-2d97-800b-8e78-f151eafdff95" class="">Type Functions</h3><p id="17c5dd5d-2d97-80f7-84b9-e1665bf0ebb3" class="">A type function is a function that is evaluated at compile time given a type as its argument or returning a type.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-8062-9296-d428edf243c0" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">constexpr float min = numeric_limits&lt;float&gt;::min();
constexpr int szi = sizeof(int);
// in &lt;type_traits&gt;
bool b = is_arithmetic_v&lt;X&gt;; 
using Res = invoke_result_t&lt;decltype(f)&gt;; // Res is int if function f returns an int
// decltype() is also a type function returning the declared type of its argument
// example: priority_queue&lt;tree, vector&lt;tree&gt;, decltype(lambda1)&gt; pq1{lambda1};</code></pre><p id="17c5dd5d-2d97-803e-afdb-f83b8462e92d" class="">Concepts are the best type functions. (But most STL as written pre-concepts and must support pre-concept codebases.) Notational conventions <mark class="highlight-blue"><code><strong>_v</strong></code></mark> for type functions that return values, <mark class="highlight-blue"><code><strong>_t</strong></code></mark> for type functions that return types.</p><p id="17c5dd5d-2d97-8014-b11d-e40e339346d8" class="">
</p><p id="17c5dd5d-2d97-8061-9fae-e795c8fd4c5a" class="">Type functions are part of C++ mechanisms for compile-time computation and allow for tight type checking.</p><p id="17c5dd5d-2d97-800b-9881-e3a1ca7cfcd1" class="">
</p><p id="17c5dd5d-2d97-8055-bd04-f02bd9a2362e" class="">Simple type functions that answer fundamental questions about types are <em>type predicates.</em></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-8011-829a-c156f76f459e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
concept Arithemtic = is_arithmetic_v&lt;T&gt;; // is_arithmetic_v type predicate

template&lt;typename T&gt;
concept Class = is_class_v&lt;T&gt; || is_union_v&lt;T&gt;; // unions are classes

template&lt;typename T&gt;
class Smart_pointer {
	// ...
	T&amp; operator*() const;
	T* operator-&gt;() const requires Class&lt;T&gt;; // -&gt; is defined if and only if T is a class or union
};</code></pre><p id="17c5dd5d-2d97-8055-bdf1-ebfe00c2693b" class="">
</p><p id="17c5dd5d-2d97-805a-8c7e-c905046eea4d" class="">Many type functions return types, often new types they that they compute. Common example is <mark class="highlight-blue"><code><strong>enable_if</strong></code></mark><mark class="highlight-blue"><strong>.</strong></mark></p><figure id="17c5dd5d-2d97-80a1-b9c1-e8658ad83079"><a href="https://medium.com/@sidbhasin82/c-templates-what-is-std-enable-if-and-how-to-use-it-fd76d3abbabe" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">C++ Templates: What is std::enable_if and how to use it?</div><div class="bookmark-description">Introduction</div></div><div class="bookmark-href"><img src="https://miro.medium.com/v2/resize:fill:304:304/10fd5c419ac61637245384e7099e131627900034828f4f386bdaa47a74eae156" class="icon bookmark-icon"/>https://medium.com/@sidbhasin82/c-templates-what-is-std-enable-if-and-how-to-use-it-fd76d3abbabe</div></div><img src="https://miro.medium.com/v2/da:true/bd978bb536350a710e8efb012513429cabdc4c28700604261aeda246d0f980b7" class="bookmark-image"/></a></figure><figure id="17c5dd5d-2d97-8074-a371-e1ba0f540f65"><a href="https://en.cppreference.com/w/cpp/types/enable_if" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">std::enable_if - cppreference.com</div><div class="bookmark-description">This metafunction is a convenient way to leverage SFINAE prior to C++20&#x27;s concepts, in particular for conditionally removing functions from the candidate set based on type traits, allowing separate function overloads or specializations based on those different type traits.</div></div><div class="bookmark-href"><img src="https://en.cppreference.com/favicon.ico" class="icon bookmark-icon"/>https://en.cppreference.com/w/cpp/types/enable_if</div></div></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-80de-94d1-e1647e25ca8b" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">R=enable_if&lt;b, T&gt; // if b is true, R is T, otherwise R is undefined

template&lt;typename T&gt;
struct is_container_type_v {
    static const bool value = false;
};

// define a new specialisation
template&lt;typename T&gt;
struct is_container_type_v&lt;vector&lt;T&gt;&gt; {
    static const bool value = true;
};
// define a new specialisation
template&lt;typename T&gt;
struct is_container_type_v&lt;set&lt;T&gt;&gt; {
    static const bool value = true;
};

// to prevent template ambiguity
template&lt;typename T&gt;
string ToString(const T&amp; x, typename enable_if&lt;!is_container_type_v&lt;T&gt;::value, int&gt;::type* = 0) {
    return to_string(x);
}

template&lt;typename T&gt;
string ToString(const T&amp; x, typename enable_if&lt;is_container_type_v&lt;T&gt;::value, int&gt;::type* = 0) { // dummy int* argument is not used
    if (x.empty()) return &quot;[]&quot;;
    
    string res = &quot;[&quot;;
    for (const auto&amp; ele : x) {
        res.append(ToString(ele));
        res.push_back(&#x27;,&#x27;);
    }
    res.back() = &#x27;]&#x27;;
    return res;
}


void fn()
{
    vector&lt;int&gt; vec{1,2,3,4,5};
    cout&lt;&lt;ToString(vec);
}</code></pre><p id="17c5dd5d-2d97-80d3-8d47-e3c547f19305" class="">
</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-8085-9642-c0e3e408279a" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T&gt;
concept Class = is_class_v&lt;T&gt; || is_union_v&lt;T&gt;;

template&lt;typename T&gt;
class Smart_pointer {
public:
    Smart_pointer(T* r) : ptr{r} {}
    T&amp; operator*() { return *ptr; }
    typename enable_if&lt;is_class_v&lt;T&gt; || is_union_v&lt;T&gt;, T*&gt;::type operator-&gt;() { return ptr; }
    // (using concepts) T* operator-&gt;() requires Class&lt;T&gt; { return ptr; }
    ~Smart_pointer() {if (ptr) delete ptr; }
private:
    T* ptr;
};

template&lt;typename T, typename U&gt;
struct MyPair {
    T first;
    U second;
};


void fn()
{
    Smart_pointer ptr{new MyPair{1,2}}; // OK: template argument deduction to Smart_pointer&lt;MyPair&lt;int, int&gt;&gt; , but error: Smart_pointer&lt;MyPair&gt;
    cout&lt;&lt;ptr-&gt;first&lt;&lt;&quot;,&quot;&lt;&lt;ptr-&gt;second; // 1,2
}</code></pre><p id="17c5dd5d-2d97-80c4-b51b-d19d23416db1" class="">
</p><h3 id="17c5dd5d-2d97-80fa-a3e0-d05a463cf1aa" class="">source_location</h3><p id="17c5dd5d-2d97-80e6-a89a-e0539fc9feff" class="">Since C++ 20. Older compilers use macros <mark class="highlight-blue"><code><strong>__FILE__</strong></code></mark> and <mark class="highlight-blue"><code><strong>__LINE__</strong></code></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-8076-b1a5-cd4db505c078" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void log(const string&amp; mess = &quot;&quot;, const source_location loc = source_location::current()) {
	cout&lt;&lt;loc.file_name()&lt;&lt;&#x27;(&#x27;&lt;&lt;loc.line()&lt;&lt;&#x27;:&#x27;&lt;&lt;loc.column()&lt;&lt;&#x27;)&#x27;&lt;&lt;loc.function_name()&lt;&lt;&quot;: &quot;&lt;&lt;mess;
}</code></pre><p id="17c5dd5d-2d97-8003-9b83-d9211c073132" class="">
</p><h3 id="17c5dd5d-2d97-80f7-b01e-fc888149d340" class="">move and forward</h3><p id="17c5dd5d-2d97-8095-8847-ffa473dcdd92" class="">Move doesn’t move anything. Instead, it casts its argument to an <mark class="highlight-blue"><code><strong>rvalue</strong></code></mark> reference (argument will not be used again and therefore may be moved). The state of a moved-from object is undefined behaviour. For container (vector/string), the moved-from state will be empty.</p><p id="17c5dd5d-2d97-8086-b652-c1c8530c5c96" class="">
</p><p id="17c5dd5d-2d97-80db-8b45-ed12e693fbf8" class="">When you see std::move, it indicates that the value of the object should not be used afterwards, but you can still assign a new value and continue using it. Thus, std::forward has a single use case: to cast a templated function parameter (inside the function) to the value category (lvalue or rvalue) the caller used to pass it. <mark class="highlight-yellow_background">This allows rvalue arguments to be passed on as rvalues, and lvalues to be passed on as lvalues</mark>, a scheme called “perfect forwarding.”</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17c5dd5d-2d97-80ab-aa64-d3f58df3fd80" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">template&lt;typename T, typename ...Args&gt;
unique_ptr&lt;T&gt; custom_make_unique(Args&amp;&amp; ...args) {
	return unique_ptr&lt;T&gt;{new T{std::forward&lt;Args&gt;(args)...}}; // allows forwarding rvalue references
};

unique_ptr&lt;pair&lt;int, int&gt;&gt; p = custom_make_unique&lt;pair&lt;int, int&gt;&gt;(5,6);</code></pre><p id="17c5dd5d-2d97-80dc-9bbf-e9ca68976869" class="">
</p><h3 id="17c5dd5d-2d97-8045-8f39-ee0ba56383fb" class="">Exiting a Program (exit vs abort)</h3><p id="17d5dd5d-2d97-80b6-bca0-ea7f5f4420b1" class=""><mark class="highlight-blue"><code><strong>exit(x):</strong></code></mark> calls functions registered with <mark class="highlight-blue"><code><strong>atexit()</strong></code></mark> then exit the program with return value x.</p><p id="17e5dd5d-2d97-80fd-a22d-c36ea6cc56d1" class=""><mark class="highlight-blue"><code><strong>abort():</strong></code></mark> exit the program immediately and unconditionally with a return value indicating unsuccessful termination.</p><p id="17e5dd5d-2d97-8026-8b02-efcfc15de921" class=""><mark class="highlight-blue"><code><strong>quick_exit(x):</strong></code></mark> calls functions registered with <mark class="highlight-blue"><code><strong>at_quick_exit()</strong></code></mark>; then exit the program with the return value x.</p><p id="17e5dd5d-2d97-80ea-b2fa-f888df8968a7" class=""><mark class="highlight-blue"><code><strong>terminate():</strong></code></mark> call the <mark class="highlight-blue"><code><strong>terminate_handler</strong></code></mark>. Default <mark class="highlight-blue"><code><strong>terminate_handler</strong></code></mark> is <mark class="highlight-blue"><code><strong>abort()</strong></code></mark>;</p><p id="17e5dd5d-2d97-8095-b95b-c25c850c118c" class="">
</p><p id="17e5dd5d-2d97-80bc-91f8-ec0ba0f2a12b" class=""><code><a href="http://en.cppreference.com/w/c/program/abort">abort()</a></code> exits your program <strong>without</strong> calling functions registered using <code><a href="http://en.cppreference.com/w/c/program/atexit">atexit()</a></code> first, and <strong>without</strong> calling objects&#x27; destructors first. <code><a href="http://en.cppreference.com/w/c/program/exit">exit()</a></code> does both before exiting your program, but does not call destructors for automatic objects (An object constructed by explicit or implicit use of a constructor is automatic and will be destroyed at the first opportunity) .</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-80dd-9b51-e6f7e3a96a4e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">A a;
void test() {
    static A b;
    A c; // automatic object
    exit(0);
}</code></pre><p id="17e5dd5d-2d97-80e5-864c-e42da980a3d9" class="">Will destruct <code>a</code> and <code>b</code> properly, but will not call destructors of <code>c</code>. <code>abort()</code> wouldn&#x27;t call destructors of neither objects. </p><p id="17e5dd5d-2d97-8092-8089-da253506af97" class="">As this is unfortunate, the C++ Standard describes an alternative mechanism which ensures properly termination:</p><blockquote id="17e5dd5d-2d97-80ff-9e1c-cb4e53d25b41" class="">Objects with automatic storage duration are all destroyed in a program whose function main() contains no automatic objects and executes the call to exit(). Control can be transferred directly to such a main() by throwing an exception that is caught in main().</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-80e3-93ad-e8ed61aaa844" class="code"><code class="language-C#" style="white-space:pre-wrap;word-break:break-all">struct exit_exception {
   int c;
   exit_exception(int c):c(c) { }
};

int main() {
    try {
        // put all code in here
    } catch(exit_exception&amp; e) {
        exit(e.c);
    }
}
</code></pre><p id="17e5dd5d-2d97-8078-91a4-eba3629c7e5c" class="">Instead of calling <code>exit()</code>, arrange that code <code>throw exit_exception(exit_code);</code> instead.</p><p id="17e5dd5d-2d97-80b3-bb49-db0d49226413" class="">
</p><h1 id="17e5dd5d-2d97-807a-9903-d02550441cf7" class="">Chapter 17: Numerics</h1><h3 id="17e5dd5d-2d97-806b-8f27-e0c5ad5c1b57" class="">Overview</h3><table id="17e5dd5d-2d97-8055-8725-eb463758bff3" class="simple-table"><tbody><tr id="6f5727b2-9e05-46fe-85a4-66d1db87877a"><td id="SzpW" class="" style="width:116.5px">numeric limits</td><td id="MI:e" class="" style="width:698.5px"><mark class="highlight-blue"><code><strong>static_assert(100000 &lt; numeric_limits&lt;int&gt;::max(), “small ints!”); // numeric_limits is constexpr</strong></code></mark></td></tr><tr id="02e23103-4569-4528-b728-1c4ba3f6ca64"><td id="SzpW" class="" style="width:116.5px">type aliases</td><td id="MI:e" class="" style="width:698.5px"><mark class="highlight-blue"><code><strong>size_t</strong></code></mark> (is alias of the type return by <mark class="highlight-blue"><code><strong>sizeof</strong></code></mark> operator) <mark class="highlight-blue"><code><strong>ptrdiff_t</strong></code></mark> (the type of result of subtracting ptrs)</td></tr><tr id="b7e5db61-79ec-40dc-9ea0-207048f32ea9"><td id="SzpW" class="" style="width:116.5px">math constants</td><td id="MI:e" class="" style="width:698.5px"><mark class="highlight-blue"><code><strong>log2e, log10e, e, pi, ln2 (log(2)), ln10</strong></code></mark></td></tr></tbody></table><h3 id="17e5dd5d-2d97-80d3-bae3-e1d431091190" class="">Random Numbers</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-8049-9b59-e80fa5ec66a9" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">srand(time(0)); // srand (seed rand) Get different random number each time the program runs
int randomNum = rand() % 101; // Generate a random number between 0 and 100</code></pre><h3 id="17e5dd5d-2d97-801f-8fb1-d2a744e2817d" class="">Valarray - Vector Arithmetic</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-8088-9a9b-c62cc92dd99c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">valarray&lt;double&gt; f(valarray&lt;double&gt;&amp; a1, valarray&lt;double&gt;&amp; a2) {
    valarray&lt;double&gt; a = a1*3.14+a2/a1; // numeric array operators *,+,/ and =
    a2 += a1*3.14;
    a = abs(a);
    double d = a2[7];
    // ...
    return a;
}</code></pre><p id="17e5dd5d-2d97-800d-b662-f3c6ea52b40e" class="">
</p><h1 id="17e5dd5d-2d97-808e-9b65-d1fb192e5ab6" class="">Chapter 18: Concurrency</h1><h3 id="17e5dd5d-2d97-8018-ba49-e253e1a4d351" class="">Task and threads</h3><p id="17e5dd5d-2d97-8083-bcda-d1b9abfd68c3" class="">Computation that can potentially be executed concurrently with other computations a <em>task</em>. A <em>thread </em>is system level representation of a task in a program. A task is a function or function object. Task is launched upon constructing a thread.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-80e3-9b7f-d13e05856c44" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void f(const vector&lt;double&gt;&amp; v, double* res); // function

class F { // function object
public:
	F(const vector&lt;double&gt;&amp; vv, double* p) : v{vv}, res{p} { }
	void operator()(); // F&#x27;s call operator
private:
	const vector&lt;double&gt;&amp; v; // source of input
	const double* res; // target output (sneaky way of returning a result - by passing ptr)
};

void user(vector&lt;double&gt;&amp; vec1, vector&lt;double&gt;&amp; vec2, vector&lt;double&gt;&amp; vec3) {
	double res1;
	double res2;
	double res3;
	
	// f(), F()() and lambda execute in separate threads - tasks are launched 
	thread t1 {f,cref(vec1), &amp;res1}; // pass const-ref arguments using cref(), ref() for non-const args
	thread t2 {F{vec2, &amp;res2}}; 
	
	thread t3 {[&amp;](){ res3 = g(vec3); }}; // [&amp;] capture local variables by reference
	
	t1.join(); // join before using results (res1, res2, res3)
	t2.join();
	t3.join();
}
</code></pre><p id="17e5dd5d-2d97-8037-a975-c7173ca7790e" class="">STL provides <mark class="highlight-blue"><code><strong>jthread</strong></code></mark>, RAII by having destructor join(). </p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-807d-a4ba-d253651bcdb3" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void user() {
	jthread t1 {f};
	jthread t2 {F{}};
}; 
// Joining is done by destructors, so in reverse order of construction. we wait for t2 before t1.</code></pre><p id="17e5dd5d-2d97-803f-97fa-e840280648f5" class="">Programming concurrent tasks can be tricky. For example, if multiple threads use <mark class="highlight-blue"><code><strong>cout</strong></code></mark> without synchronization, result is unpredictable. Consider one thread use a stream or use <mark class="highlight-blue"><code><strong>osyncstream</strong></code></mark>. </p><p id="17e5dd5d-2d97-800f-9bce-f872fe42c5a0" class="">
</p><h3 id="17e5dd5d-2d97-8021-b65f-c312d9f82dab" class="">Mutexes and Locks</h3><p id="17e5dd5d-2d97-806b-8cf4-ff73a3962065" class="">Mutex (mutual exclusion object) is a key element of general sharing of data between threads. Use of resource handles, like <mark class="highlight-blue"><code><strong>scoped_lock </strong></code></mark>and <mark class="highlight-blue"><code><strong>unique_lock</strong></code></mark>, is far safer and simpler due to RAII. </p><p id="17e5dd5d-2d97-80fc-9aab-fb27682915d1" class="">
</p><p id="17e5dd5d-2d97-8061-8fea-fe9bce02a8e0" class=""><mark class="highlight-red"><strong>Deadlock scenario</strong></mark>: if thread1 acquires mutex1 and then tries to acquire mutex2 while thread2 acquires mutex2 and then tries to acquire mutex1, neither task will ever proceed further. <mark class="highlight-blue"><code><strong>scoped_lock</strong></code></mark> helps by enabling us to acquire several locks simultaneously, and will only proceed after acquiring all mutexes arguments and <mark class="highlight-yellow_background">will never block (go to sleep w</mark><mark class="highlight-yellow_background"><strong>hen a process is waiting for an event or resource</strong></mark><mark class="highlight-yellow_background">) while holding a mutex.</mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17e5dd5d-2d97-80cb-a81d-fd295e896c81" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">void f() {
	scoped_lock lck{mutex1, mutex2, mutex3}; // acquire all 3 locks
	// ... manipulate shared data
} // implicitly release resources via mutex1.unlock(); mutex2.unlock(); mutex3.unlock();</code></pre><p id="17f5dd5d-2d97-802b-9914-cbe176e2301d" class="">
</p><p id="17f5dd5d-2d97-8093-9413-cbfd0025ef90" class="">Sharing data among many readers and one writer, we can use <mark class="highlight-blue"><code><strong>shared_mutex</strong></code></mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80a4-999a-ecdab80b1362" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class ThreadSafeCounter {
public:
    ThreadSafeCounter() = default;
    // using shared mutex, multiple threads can read at same time
    unsigned int get() const {
        shared_lock lck(mx_);
        return value_;
    }
    // unique_lock on shared_mutex, so only one thread can write at given point in time
    void increment() {
        unique_lock lck(mx_);
        ++value_;
    }
    
    void reset() {
        unique_lock lck(mx_);
        value_ = 0;
    }
private:
    /* The keyword mutable is mainly used to allow a particular data member of const object to be modified.
    
    With your const reference or pointer you are constrained to:
        1) only read access for any visible data members
        2) permission to call only methods that are marked as const.
    The mutable exception makes it so you can now write or set data members that are marked mutable. 
    hat&#x27;s the only externally visible difference. */
    mutable shared_mutex mx_;  
    unsigned int value_{};
};

void fn()
{
    ThreadSafeCounter counter;
    auto increment_and_print = [&amp;counter]()
    {
        for (int i{}; i != 3; ++i)
        {
            counter.increment();
            std::osyncstream(std::cout)
                &lt;&lt; std::this_thread::get_id() &lt;&lt; &#x27; &#x27; &lt;&lt; counter.get() &lt;&lt; &#x27;\n&#x27;;
        }
    };
 
    std::jthread thread1(increment_and_print);
    std::jthread thread2(increment_and_print);
}</code></pre><p id="17f5dd5d-2d97-80d8-b96c-e7b4ae0c50ee" class="">
</p><p id="17f5dd5d-2d97-80c8-8cc6-e059c7430041" class="">Communicating (i.e, message) using external events is provided by <mark class="highlight-blue"><code><strong>condition_variable</strong></code></mark>.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-8008-915b-c2381e5f2af6" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">class Message { ... } // object to be communicated

queue&lt;Message&gt; mqueue;
conditon_variable mcond;
mutex mmutex; // for synchronising access to mcond

void consumer() {
	while (true) {
		unique_lock lck{mmutex};
		mcond.wait(lck, []{ return !mqueue.empty(); }); 
		// release mmutex and wait reacquire mmutex on wakeup. Wakeup condition: !mqueue.empty()
		auto m = mqueue.front();
		mqueue.pop();
		lck.unlock(); // release mmutex
		// ... process m
	}
}

void producer() {
	while (true) {
		Message m;
		// ... fill message
		scoped_lock lck{mmutex};
		mqueue.push(m);
		mcond.notify_one(); // notify and then mmutex (as it is end of scope)
	}
}</code></pre><p id="17f5dd5d-2d97-808c-af7c-f74a19087a08" class="">We use <mark class="highlight-blue"><code><strong>unique_lock </strong></code></mark>for consumer for 2 reasons:</p><ul id="17f5dd5d-2d97-807a-8d46-c0f14a18580a" class="bulleted-list"><li style="list-style-type:disc">Pass <mark class="highlight-blue"><code><strong>lck</strong></code></mark> to <mark class="highlight-blue"><code><strong>conditon_variable</strong></code></mark> <mark class="highlight-blue"><code><strong>wait()</strong></code></mark><mark class="highlight-blue"><strong>. </strong></mark><mark class="highlight-blue"><code><strong>scoped_lock</strong></code></mark><mark class="highlight-default"> cannot be moved, but </mark><mark class="highlight-blue"><code><strong>unique_lock</strong></code></mark><mark class="highlight-default"> can.</mark></li></ul><ul id="17f5dd5d-2d97-8030-8e28-e1c21a67b8c5" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-blue"><code><strong>unique_lock</strong></code></mark> has <mark class="highlight-blue"><code><strong>lock()</strong></code></mark> and <mark class="highlight-blue"><code><strong>unlock()</strong></code></mark>, but <code>‘class std::scoped_lock’ has no member named ‘unlock’</code></li></ul><h3 id="17e5dd5d-2d97-80c1-b52e-fb4a61564668" class="">Atomics</h3><p id="17f5dd5d-2d97-80b8-94c8-d389389dc3f9" class="">Each instantiation and full specialization of the <mark class="highlight-blue"><code><strong>std::atomic</strong></code></mark> template defines an atomic type. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see <a href="https://en.cppreference.com/w/cpp/language/memory_model">memory model</a> for details on data races).</p><p id="17f5dd5d-2d97-8085-b59f-ca9a9429bc90" class="">Well-defined means that accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>.</p><p id="17f5dd5d-2d97-8074-8184-d8b029fc30e3" class=""><mark class="highlight-blue"><code><strong>std::atomic </strong></code></mark>is neither copyable nor movable.</p><p id="17f5dd5d-2d97-8000-a1c5-fe4499982359" class="">
</p><h3 id="17f5dd5d-2d97-807e-be03-f6497a30604a" class="">future, promise and packaged_task</h3><p id="17f5dd5d-2d97-80e2-9bb1-ce10e46ae6d7" class="">A <mark class="highlight-blue"><code><strong>packaged_task</strong></code></mark> gets a <mark class="highlight-blue"><code><strong>future</strong></code></mark> into the task that need a result and the corresponding <mark class="highlight-blue"><code><strong>promise </strong></code></mark>into the thread that should produce the result. A <mark class="highlight-blue"><code><strong>packaged_task</strong></code></mark> cannot be copied (since it itself is a resource handle, it owns its <mark class="highlight-blue"><code><strong>promise</strong></code></mark>), only can be moved.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80d5-a57e-c409cd9902ce" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">double accum(vector&lt;double&gt;::iterator beg, vector&lt;double&gt;::iterator end, double init) {
	return accumulate(&amp;*beg,&amp;*end,init);
} 

double comp2(vector&lt;double&gt;&amp; v) {
	packaged_task pt0{accum};
  packaged_task pt1{accum};
  
  future&lt;double&gt; f0 {pt0.get_future()};
  future&lt;double&gt; f1 {pt1.get_future()};
  
  double* first = &amp;v[0];
  thread t1{move(pt0),first,first+v.size()/2,0};
  thread t2{move(pt1),first+v.size()/2,first+v.size(),0};
  return f0.get()+f1.get(); 
}</code></pre><p id="17f5dd5d-2d97-80c3-8da1-df91927a3ee6" class="">
</p><h3 id="17f5dd5d-2d97-8096-a784-e4311a7d52ba" class="">async()</h3><p id="17f5dd5d-2d97-80d9-b34f-d82f36ef0fc4" class="">The function template <code>std::async</code> runs the function f asynchronously (potentially in a separate thread which might be a part of a thread pool) and returns a <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> that will eventually hold the result of that function call.</p><p id="17f5dd5d-2d97-80c8-a22a-f8dc25ce5bb5" class="">Limitation: Don’t even think of using async() for tasks that shares resources and hence need locking. With async(), system decides number of threads to use.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-806a-87b9-cce707598b99" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">auto f0 = async(accum, first,first+v.size()/2,0);
auto f1 = async(accum,first+v.size()/2,first+v.size(),0);
return f0.get() + f1.get();</code></pre><p id="17f5dd5d-2d97-8094-ae6c-eae79a3c705e" class="">
</p><h3 id="17f5dd5d-2d97-80e4-8a92-d0ffe3320424" class="">Stopping a thread</h3><p id="17f5dd5d-2d97-80a5-9fca-c20cac92786a" class="">Thread can own resources that must be released (locks, sub-threads, db connections).  STL provides to proper clean up with <mark class="highlight-blue"><code><strong>stop_token</strong></code></mark><mark class="highlight-blue"><strong>. </strong></mark><mark class="highlight-default">(Since C++ 20)</mark></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80bd-836f-e70896a102a2" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">#include &lt;iostream&gt;
#include &lt;thread&gt;
 
using namespace std::literals::chrono_literals;
 
void f(std::stop_token stop_token, int value)
{
    while (!stop_token.stop_requested())
    {
        std::cout &lt;&lt; value++ &lt;&lt; &#x27; &#x27; &lt;&lt; std::flush;
        std::this_thread::sleep_for(200ms);
    }
    std::cout &lt;&lt; std::endl;
}
 
int main()
{
    std::jthread thread(f, 5); // prints 5 6 7 8... for approximately 3 seconds
    std::this_thread::sleep_for(3s);
    // The destructor of jthread calls request_stop() and join().
}</code></pre><p id="17f5dd5d-2d97-8044-b9cd-ccffbef8bf7d" class="">
</p><h3 id="17f5dd5d-2d97-8073-9920-fd8a983562fc" class="">Coroutines</h3><p id="17f5dd5d-2d97-80c2-bcad-ffe17776ec2a" class="">A coroutine is a function that maintains its state between calls. In that, it’s a bit like a function object, but saving and restoring its state between calls.  If you need 1000 tasks, w<em>hy not threads for such applications?</em> A thread requires a megabyte or two (mostly for its stack), a coroutine often only a couple of dozen bytes. Moreover, context-switching between coroutines is far faster than between threads/processes.</p><p id="17f5dd5d-2d97-8020-b8c0-f49a8cf45e98" class="">
</p><p id="17f5dd5d-2d97-8065-aae4-e11e9dabd8fc" class="">Coroutine state is allocated dynamically via non-array <a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">operator new</a>. When the coroutine state is destroyed either because it terminated via <mark class="highlight-blue"><code><strong>co_return</strong></code></mark> or uncaught exception, or because it was destroyed via its handle, it does the following:</p><ul id="17f5dd5d-2d97-809b-a03e-ea04e3a9dc18" class="bulleted-list"><li style="list-style-type:disc">calls the destructor of the promise object.</li></ul><ul id="17f5dd5d-2d97-80d0-b46d-f8b00a29968f" class="bulleted-list"><li style="list-style-type:disc">calls the destructors of the function parameter copies.</li></ul><ul id="17f5dd5d-2d97-8083-b4a8-c51a69792f43" class="bulleted-list"><li style="list-style-type:disc">calls <a href="https://en.cppreference.com/w/cpp/memory/new/operator_delete">operator delete</a> to free the memory used by the coroutine state.</li></ul><ul id="17f5dd5d-2d97-808a-8df3-c7515192eed8" class="bulleted-list"><li style="list-style-type:disc">transfers execution back to the caller/resumer.</li></ul><p id="17f5dd5d-2d97-8067-a07e-dc0892bfaf99" class="">
</p><p id="17f5dd5d-2d97-8058-ac26-cb268bf7294c" class="">The call to <a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">operator new</a> can be optimized out (even if custom allocator is used) if</p><ul id="17f5dd5d-2d97-8005-99a5-f8a3946799c8" class="bulleted-list"><li style="list-style-type:disc">The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</li></ul><ul id="17f5dd5d-2d97-803e-aa51-d29cba39420c" class="bulleted-list"><li style="list-style-type:disc">the size of coroutine frame is known at the call site.</li></ul><p id="17f5dd5d-2d97-8023-b1f0-e31f29926e36" class="">In that case, coroutine state is embedded in the caller&#x27;s stack frame (if the caller is an ordinary function) or coroutine state (if the caller is a coroutine).</p><p id="17f5dd5d-2d97-8041-a6cf-f4c6b7807c2c" class="">
</p><p id="17f5dd5d-2d97-8002-933c-fcc98c63ac1e" class="">A function is a coroutine if its definition contains any of the following:</p><ul id="17f5dd5d-2d97-8060-b951-fd66ad1b1ac1" class="bulleted-list"><li style="list-style-type:disc">the <mark class="highlight-blue"><code>co_await</code></mark> expression — to suspend execution until resumed</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80f1-a3ac-fe3877f20f2d" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">task&lt;&gt; tcp_echo_server()
{
    char data[1024];
    while (true)
    {
        std::size_t n = co_await socket.async_read_some(buffer(data));
        co_await async_write(socket, buffer(data, n));
    }
}</code></pre><ul id="17f5dd5d-2d97-8091-a66d-f1686dae6f8e" class="bulleted-list"><li style="list-style-type:disc">the <mark class="highlight-blue"><code><strong>co_yield</strong></code></mark> expression — to suspend execution returning a value</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-8011-962e-f9dc9994ec8c" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">generator&lt;unsigned int&gt; iota(unsigned int n = 0)
{
    while (true)
        co_yield n++;
}`</code></pre><ul id="17f5dd5d-2d97-8085-a45b-c5929ac1db53" class="bulleted-list"><li style="list-style-type:disc">the <mark class="highlight-blue"><code><strong>co_return</strong></code></mark> statement — to complete execution returning a value</li></ul><p id="17f5dd5d-2d97-8089-b8e9-fa4ce25dd1c1" class="">
</p><p id="17f5dd5d-2d97-80f3-af33-cb8c01d94b8a" class="">Coroutines cannot use <a href="https://en.cppreference.com/w/cpp/language/variadic_arguments">variadic arguments</a>, plain <a href="https://en.cppreference.com/w/cpp/language/return">return</a> statements, or <a href="https://en.cppreference.com/w/cpp/language/function">placeholder return types</a> (<code><a href="https://en.cppreference.com/w/cpp/language/auto">auto</a></code> or <a href="https://en.cppreference.com/w/cpp/language/constraints#Concepts">Concept</a>).</p><p id="17f5dd5d-2d97-80e3-ae4e-c5f9f56fe672" class=""><a href="https://en.cppreference.com/w/cpp/language/consteval">Consteval functions</a>, <a href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr functions</a>, <a href="https://en.cppreference.com/w/cpp/language/constructor">constructors</a>, <a href="https://en.cppreference.com/w/cpp/language/destructor">destructors</a>, and the <a href="https://en.cppreference.com/w/cpp/language/main_function">main function</a> cannot be coroutines.</p><p id="17f5dd5d-2d97-8035-8bf9-dc86d195c9c1" class="">
</p><h1 id="17f5dd5d-2d97-8088-a101-dd11971330d0" class="">Chapter 19: History and Compatibility</h1><h3 id="17f5dd5d-2d97-8037-9467-daf37d5e65e0" class="">Struct Alignment</h3><p id="17f5dd5d-2d97-8005-82cc-dc3d875a4172" class="">Alignment matters not only for performance, but also for correctness. Some architectures will fail with an processor trap if the data is not aligned correctly, or access the wrong memory location. <mark class="highlight-yellow_background">On others, access to unaligned variables is broken into multiple accesses and bitshifts (often inside the hardware, sometimes by OS trap handler), losing atomicity.</mark></p><p id="17f5dd5d-2d97-806c-bbf2-ff562a1e4e29" class=""><strong>The advice to sort members in descending order of size (biggest to smallest) is for optimal packing / minimum space wasted by padding, not for alignment or speed.</strong> Members will be correctly aligned no matter what order you list them in, unless you request non-conformant layout using specialized pragmas (i.e. the non-portable <code>#pragma pack</code>) or keywords. Although total structure size is affected by padding and also affects speed, often there is another ordering that is optimal.</p><p id="17f5dd5d-2d97-80a8-82e1-c9f575c6e0ec" class="">For best performance, you should try to get members which are used together into the same cache line, and members that are accessed by different threads into different cache lines. Sometimes that means a lot of padding to get a cross-thread shared variable alone in its own cache line. But that&#x27;s better than taking a performance hit from false sharing.</p><p id="17f5dd5d-2d97-80d8-b73d-ebb967f657d5" class="">
</p><h3 id="17f5dd5d-2d97-80cb-b5f5-f1dd617af83f" class="">void*</h3><p id="17f5dd5d-2d97-8088-bb3f-c8c38f366aed" class="">void* cannot be used as RHS operand of an assignment in initialization of a variable of any pointer type.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80b7-8bb6-e6f1bf606679" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">char ch;
void* pv = &amp;ch; // OK
int* pi = pv; // Error: invalid conversion from ‘void*’ to ‘int*’</code></pre><p id="17f5dd5d-2d97-80e1-84d2-d4f62767c177" class="">
</p><h3 id="17f5dd5d-2d97-8024-865d-c53df93bc9f2" class="">extern</h3><p id="17f5dd5d-2d97-8022-a95e-ed0fe65163e6" class="">It is useful when you share a variable between a few modules. You define it in one module, and use extern in the others. When the linker sees <mark class="highlight-blue"><code><strong>extern</strong></code></mark> before a global variable declaration, it looks for the definition in another translation unit. Declarations of non-<mark class="highlight-blue"><code><strong>const</strong></code></mark> variables at global scope are external by default. Only apply <mark class="highlight-blue"><code><strong>extern</strong></code></mark> to the declarations that don&#x27;t provide the definition.<br/><br/></p><p id="17f5dd5d-2d97-80c5-baf9-c4c483668d83" class="">For example:</p><p id="17f5dd5d-2d97-80fb-b46c-ecb470ab728e" class="">in file1.cpp:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-80d2-90af-d549f4d40623" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">int global_int = 1;</code></pre><p id="17f5dd5d-2d97-80d7-a8a7-c42469c1a96d" class="">in file2.cpp:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f5dd5d-2d97-8063-92fd-fd8503d4a68e" class="code"><code class="language-C++" style="white-space:pre-wrap;word-break:break-all">extern int global_int;
//in some function
cout &lt;&lt; &quot;global_int = &quot; &lt;&lt; global_int;</code></pre></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>
